%include
{
/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Copyright (C) 2019-2021 OpenCFD Ltd.
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Description
    Lemon grammar for volume expressions.

    https://www.sqlite.org/src/doc/trunk/doc/lemon.html

    See detailed notes in the field expression parser.

\*---------------------------------------------------------------------------*/
} // %include

/*
 * include volumeExprLemonParserMacros.m4
 * !done in a comment since many editors have issues matching m4 quotes!
 */
%include
{
#include "exprScanToken.H"
#include "volumeExprDriver.H"
#include "volumeExprParser.H"
#include "volumeExprScanner.H"
#include "volFields.H"
#include "surfaceFields.H"
#include "pointFields.H"
#include "unitConversion.H"
#include "error.H"
#include "IOmanip.H"
#include "exprOps.H"
#include "exprDriverOps.H"
#include "GeometricFieldOps.H"
#include "fvcReconstruct.H"


// Enable ParseTrace
#undef NDEBUG

#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wsign-compare"

// Local Functions

//- Create a tmp from a pointer, taking ownership
template<class T>
Foam::tmp<T> make_tmp(T* p)
{
    return Foam::tmp<T>(p);
}

//- Default make_obj is pass-through
template<class T>
const T& make_obj(const T& o) noexcept
{
    return o;
}

//- Move construct an object from a pointer and destroy the pointer
template<class T>
T make_obj(T*& p)
{
    T o(std::move(*p));
    delete p;
    p = nullptr;  // Prevent caller from deleting too
    return o;
}


} // %include

// ------------------------------------------------------------------------- //

// File-scope visibility for exposed Lemon parser routines
%static

// Use extra argument for the return value
%extra_context  { Foam::expressions::volumeExpr::parseDriver* driver }
%parse_failure  { driver->reportFatal("Parse failure, giving up..."); }
%syntax_error   { driver->reportFatal("Syntax error"); }

%token_prefix TOK_

// Terminals
%token_type         {Foam::expressions::scanToken}
%token_destructor   { ($$).destroy(); }

// Volume fields
%type lfield { Foam::volScalarField* }
%type sfield { Foam::volScalarField* }
%type vfield { Foam::volVectorField* }
%type hfield { Foam::volSphericalTensorField* }
%type yfield { Foam::volSymmTensorField* }
%type tfield { Foam::volTensorField* }

// Surface fields
%type slfield { Foam::surfaceScalarField* }
%type ssfield { Foam::surfaceScalarField* }
%type svfield { Foam::surfaceVectorField* }
%type shfield { Foam::surfaceSphericalTensorField* }
%type syfield { Foam::surfaceSymmTensorField* }
%type stfield { Foam::surfaceTensorField* }

// Point fields
%type plfield { Foam::pointScalarField* }
%type psfield { Foam::pointScalarField* }
%type pvfield { Foam::pointVectorField* }
%type phfield { Foam::pointSphericalTensorField* }
%type pyfield { Foam::pointSymmTensorField* }
%type ptfield { Foam::pointTensorField* }

// For each rule action with code, destruction must be done by that code block
// Lemon does not generate a destructor for that.
// So do not use Lemon destructors for anything.

// Standard tokens for operators, constants and common types
%token
  LPAREN RPAREN COMMA
  QUESTION COLON LOR LAND LNOT
  BIT_OR BIT_XOR BIT_AND BIT_NOT
  EQUAL NOT_EQUAL
  LESS LESS_EQUAL GREATER GREATER_EQUAL
  PLUS MINUS TIMES DIVIDE PERCENT
  NEGATE DOT
  BOOL LTRUE LFALSE
  NUMBER ZERO IDENTIFIER
.

// https://en.cppreference.com/w/cpp/language/operator_precedence
%right QUESTION COLON .                 // 13: right-to-left
%left LOR  .                            // 12:
%left LAND .                            // 11:
%left BIT_OR  .                         // 10 (unused)
%left BIT_XOR .                         // 9
%left BIT_AND .                         // 8
%left EQUAL NOT_EQUAL .                 // 7
%left LESS LESS_EQUAL GREATER GREATER_EQUAL . // 6
%left PLUS MINUS .                      // 4
%left TIMES DIVIDE PERCENT .            // 3
%right NEGATE LNOT BIT_NOT .            // 2: right-to-left
%left DOT  .                            // 1: (method)


%start_symbol evaluate

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/*---------------------------------------------------------------------------*\
 * General Productions
\*---------------------------------------------------------------------------*/

%type identifier { Foam::word* }
%destructor identifier { delete($$); $$ = nullptr; }

identifier (lhs) ::= IDENTIFIER (tok) .
{
    // Take ownership of pointer from scan token
    lhs = tok.name_; tok.name_ = nullptr;
}


/*---------------------------------------------------------------------------*\
 * Productions (scalar)
\*---------------------------------------------------------------------------*/

%type svalue { Foam::scalar }

svalue (lhs) ::= NUMBER (tok) .     { lhs = (tok).scalarValue; } // scanToken
svalue (lhs) ::= ZERO .             { lhs = Foam::Zero; }
svalue (lhs) ::= PI LPAREN RPAREN . { lhs = Foam::constant::mathematical::pi; }
svalue (lhs) ::= DEG_TO_RAD LPAREN RPAREN . { lhs = Foam::degToRad(); }
svalue (lhs) ::= RAD_TO_DEG LPAREN RPAREN . { lhs = Foam::radToDeg(); }
svalue (lhs) ::= ARG LPAREN RPAREN .  { lhs = driver->argValue(); }
svalue (lhs) ::= TIME LPAREN RPAREN . { lhs = driver->timeValue(); }
svalue (lhs) ::= DELTA_T LPAREN RPAREN . { lhs = driver->deltaT(); }

svalue (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN RPAREN .
{
    lhs = driver->getFunctionValue<Foam::scalar>
    (
        make_obj(name.name_),
        driver->timeValue()
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (vector)
\*---------------------------------------------------------------------------*/

%type vvalue { Foam::vector* }
%destructor vvalue { delete($$); $$ = nullptr; }

vvalue (lhs) ::= VECTOR_VALUE (tok) .
{
    // Take ownership of pointer from scan token
    lhs = tok.vectorPtr; tok.vectorPtr = nullptr;
}

vvalue (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN RPAREN .
{
    auto val = driver->getFunctionValue<Foam::vector>
    (
        make_obj(name.name_),
        driver->timeValue()
    );
    lhs = new Foam::vector(val);
}


/* * * * * * * * * * * * * * * * Volume Fields * * * * * * * * * * * * * * * *\
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*---------------------------------------------------------------------------*\
 * Productions (volScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= sfield (a) . { driver->setResult(a); }

sfield (lhs) ::= svalue (a) .
{
    lhs = driver->newVolField<Foam::scalar>(make_obj(a)).ptr();
}

sfield (lhs) ::= SCALAR_ID (name) .
{
    lhs = driver->getVolField<Foam::scalar>(make_obj(name.name_)).ptr();
}


sfield (lhs) ::= LPAREN sfield (a) RPAREN. { lhs = a; }
sfield (lhs) ::= MINUS sfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

sfield (lhs) ::= DEG_TO_RAD LPAREN sfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

sfield (lhs) ::= RAD_TO_DEG LPAREN sfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

sfield (lhs) ::= MIN LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= MAX LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= sfield (a) EQUAL sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) NOT_EQUAL sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) LESS sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) LESS_EQUAL sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) GREATER sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) GREATER_EQUAL sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::scalar>());
}

sfield (lhs) ::= lfield (cond) QUESTION sfield (a) COLON sfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::scalar,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




sfield (lhs) ::= MIN LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

sfield (lhs) ::= MAX LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

sfield (lhs) ::= SUM LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

sfield (lhs) ::= AVERAGE LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


sfield (lhs) ::= sfield (a) PLUS sfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) MINUS sfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::scalar>()
    );
}

sfield (lhs) ::= sfield (a) PERCENT sfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarModuloOp<Foam::scalar>()
    );
}

sfield (lhs) ::= vfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

sfield (lhs) ::= EXP LPAREN sfield (a) RPAREN .
{
    lhs = Foam::exp (make_tmp(a)).ptr();
}

sfield (lhs) ::= LOG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::log (make_tmp(a)).ptr();
}

sfield (lhs) ::= LOG10 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::log10 (make_tmp(a)).ptr();
}

sfield (lhs) ::= SQR LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sqr (make_tmp(a)).ptr();
}

sfield (lhs) ::= SQRT LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sqrt (make_tmp(a)).ptr();
}

sfield (lhs) ::= CBRT LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cbrt (make_tmp(a)).ptr();
}

sfield (lhs) ::= SIN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sin (make_tmp(a)).ptr();
}

sfield (lhs) ::= COS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cos (make_tmp(a)).ptr();
}

sfield (lhs) ::= TAN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::tan (make_tmp(a)).ptr();
}

sfield (lhs) ::= ASIN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::asin (make_tmp(a)).ptr();
}

sfield (lhs) ::= ACOS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::acos (make_tmp(a)).ptr();
}

sfield (lhs) ::= ATAN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::atan (make_tmp(a)).ptr();
}

sfield (lhs) ::= SINH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sinh (make_tmp(a)).ptr();
}

sfield (lhs) ::= COSH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cosh (make_tmp(a)).ptr();
}

sfield (lhs) ::= TANH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::tanh (make_tmp(a)).ptr();
}

sfield (lhs) ::= POW LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::pow(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= ATAN2 LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::atan2(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= POS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::pos (make_tmp(a)).ptr();
}

sfield (lhs) ::= NEG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::neg (make_tmp(a)).ptr();
}

sfield (lhs) ::= POS0 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::pos0 (make_tmp(a)).ptr();
}

sfield (lhs) ::= NEG0 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::neg0 (make_tmp(a)).ptr();
}

sfield (lhs) ::= SIGN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sign (make_tmp(a)).ptr();
}



// Non-standard but manage via FieldOps::assign
sfield (lhs) ::= FLOOR LPAREN sfield (a) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::floorOp<Foam::scalar>());
}

sfield (lhs) ::= CEIL LPAREN sfield (a) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::ceilOp<Foam::scalar>());
}

sfield (lhs) ::= ROUND LPAREN sfield (a) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::roundOp<Foam::scalar>());
}


// Non-standard but manage via FieldOps::assign
sfield (lhs) ::= HYPOT LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::hypotOp<Foam::scalar>());
}



// Other functions

sfield (lhs) ::= RAND LPAREN RPAREN .
{
    lhs = driver->field_rand().ptr();
}

sfield (lhs) ::= RAND LPAREN NUMBER (seed) RPAREN .
{
    // Call with -ve seed to signal use of time index as seed
    lhs = driver->field_rand(std::round(-(seed).scalarValue)).ptr();
}

sfield (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN sfield (values) RPAREN.
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    driver->fillFunctionValues<Foam::scalar>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (volVectorField)
\*---------------------------------------------------------------------------*/

evaluate ::= vfield (a) . { driver->setResult(a); }

vfield (lhs) ::= vvalue (a) .
{
    lhs = driver->newVolField<Foam::vector>(make_obj(a)).ptr();
}

vfield (lhs) ::= VECTOR_ID (name) .
{
    lhs = driver->getVolField<Foam::vector>(make_obj(name.name_)).ptr();
}


vfield (lhs) ::= LPAREN vfield (a) RPAREN. { lhs = a; }
vfield (lhs) ::= MINUS vfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

vfield (lhs) ::= DEG_TO_RAD LPAREN vfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

vfield (lhs) ::= RAD_TO_DEG LPAREN vfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

vfield (lhs) ::= MIN LPAREN vfield (a) COMMA vfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

vfield (lhs) ::= MAX LPAREN vfield (a) COMMA vfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= vfield (a) EQUAL vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) NOT_EQUAL vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) LESS vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) LESS_EQUAL vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) GREATER vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) GREATER_EQUAL vfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::vector>());
}

vfield (lhs) ::= lfield (cond) QUESTION vfield (a) COLON vfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::vector,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




vfield (lhs) ::= MIN LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

vfield (lhs) ::= MAX LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

vfield (lhs) ::= SUM LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

vfield (lhs) ::= AVERAGE LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


vfield (lhs) ::= vfield (a) PLUS vfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) MINUS vfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

vfield (lhs) ::= sfield (a) TIMES vfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newVolField<Foam::vector>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::vector>()
    );
}

vfield (lhs) ::= vfield (a) BIT_XOR vfield (b) .
{
    lhs = (make_tmp(a) ^ make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= tfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= yfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= hfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




// Other functions

vfield (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN sfield (values) RPAREN.
{
    lhs = driver->newVolField<Foam::vector>().ptr();
    driver->fillFunctionValues<Foam::vector>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (volSphericalTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= hfield (a) . { driver->setResult(a); }

hfield (lhs) ::= SPH_TENSOR_ID (name) .
{
    lhs = driver->getVolField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}


hfield (lhs) ::= LPAREN hfield (a) RPAREN. { lhs = a; }
hfield (lhs) ::= MINUS hfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

hfield (lhs) ::= DEG_TO_RAD LPAREN hfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

hfield (lhs) ::= RAD_TO_DEG LPAREN hfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

hfield (lhs) ::= MIN LPAREN hfield (a) COMMA hfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

hfield (lhs) ::= MAX LPAREN hfield (a) COMMA hfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= hfield (a) EQUAL hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) NOT_EQUAL hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) LESS hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) LESS_EQUAL hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) GREATER hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) GREATER_EQUAL hfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::sphericalTensor>());
}

hfield (lhs) ::= lfield (cond) QUESTION hfield (a) COLON hfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::sphericalTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




hfield (lhs) ::= MIN LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

hfield (lhs) ::= MAX LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

hfield (lhs) ::= SUM LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

hfield (lhs) ::= AVERAGE LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


hfield (lhs) ::= hfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

hfield (lhs) ::= sfield (a) TIMES hfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newVolField<Foam::sphericalTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::sphericalTensor>()
    );
}




/*---------------------------------------------------------------------------*\
 * Productions (volSymmTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= yfield (a) . { driver->setResult(a); }

yfield (lhs) ::= SYM_TENSOR_ID (name) .
{
    lhs = driver->getVolField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}

yfield (lhs) ::= LPAREN yfield (a) RPAREN. { lhs = a; }
yfield (lhs) ::= MINUS yfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

yfield (lhs) ::= DEG_TO_RAD LPAREN yfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

yfield (lhs) ::= RAD_TO_DEG LPAREN yfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

yfield (lhs) ::= MIN LPAREN yfield (a) COMMA yfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

yfield (lhs) ::= MAX LPAREN yfield (a) COMMA yfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= yfield (a) EQUAL yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) NOT_EQUAL yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) LESS yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) LESS_EQUAL yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) GREATER yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) GREATER_EQUAL yfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::symmTensor>());
}

yfield (lhs) ::= lfield (cond) QUESTION yfield (a) COLON yfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::symmTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




yfield (lhs) ::= MIN LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

yfield (lhs) ::= MAX LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

yfield (lhs) ::= SUM LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

yfield (lhs) ::= AVERAGE LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


yfield (lhs) ::= yfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

yfield (lhs) ::= sfield (a) TIMES yfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newVolField<Foam::symmTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::symmTensor>()
    );
}

yfield (lhs) ::= yfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




/*---------------------------------------------------------------------------*\
 * Productions (volTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= tfield (a) . { driver->setResult(a); }
tfield (lhs) ::= IDENTITY_TENSOR . { lhs = driver->newVolField<Foam::tensor>(Foam::tensor::I).ptr(); }

tfield (lhs) ::= TENSOR_ID (name) .
{
    lhs = driver->getVolField<Foam::tensor>(make_obj(name.name_)).ptr();
}


tfield (lhs) ::= LPAREN tfield (a) RPAREN. { lhs = a; }
tfield (lhs) ::= MINUS tfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

tfield (lhs) ::= DEG_TO_RAD LPAREN tfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

tfield (lhs) ::= RAD_TO_DEG LPAREN tfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

tfield (lhs) ::= MIN LPAREN tfield (a) COMMA tfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

tfield (lhs) ::= MAX LPAREN tfield (a) COMMA tfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= tfield (a) EQUAL tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) NOT_EQUAL tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) LESS tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) LESS_EQUAL tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) GREATER tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) GREATER_EQUAL tfield (b) .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::tensor>());
}

tfield (lhs) ::= lfield (cond) QUESTION tfield (a) COLON tfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::tensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




tfield (lhs) ::= MIN LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

tfield (lhs) ::= MAX LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

tfield (lhs) ::= SUM LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

tfield (lhs) ::= AVERAGE LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


tfield (lhs) ::= tfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= sfield (a) TIMES tfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newVolField<Foam::tensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::tensor>()
    );
}

tfield (lhs) ::= vfield (a) TIMES vfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




/*---------------------------------------------------------------------------*\
 * Logic field productions (volScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= lfield (a) . { driver->setResult(a, true); /* Logical */ }

lfield (lhs) ::= LTRUE .   { lhs = driver->newVolField<Foam::scalar>(Foam::scalar(1)).ptr(); }
lfield (lhs) ::= LFALSE .  { lhs = driver->newVolField<Foam::scalar>(Foam::scalar(0)).ptr(); }

lfield (lhs) ::= BOOL LPAREN lfield (a) RPAREN .
{
    lhs = a;
}

lfield (lhs) ::= BOOL LPAREN sfield (a) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();

    Foam::FieldOps::assign
    (
        *lhs, make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}


lfield (lhs) ::= LPAREN lfield (a) RPAREN. { lhs = a; }
lfield (lhs) ::= LNOT lfield (a). [NEGATE]
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a,
        Foam::expressions::boolNotOp<Foam::scalar>()
    );
}

lfield (lhs) ::= lfield (a) LAND lfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolAndOp<Foam::scalar>()
    );
}

lfield (lhs) ::= lfield (a) LOR lfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolOrOp<Foam::scalar>()
    );
}




/*---------------------------------------------------------------------------*\
 * General Volume-related productions
\*---------------------------------------------------------------------------*/

lfield (lhs) ::= CELL_SET LPAREN identifier (name) RPAREN .{    lhs = driver->field_cellSet(make_obj(name)).ptr();}lfield (lhs) ::= CELL_ZONE LPAREN identifier (name) RPAREN .{
    lhs = driver->field_cellZone(make_obj(name)).ptr();}sfield (lhs) ::= CELL_VOLUME LPAREN RPAREN .
{
    lhs = driver->field_cellVolume().ptr();
}
vfield (lhs) ::= POS LPAREN RPAREN .
{
    lhs = driver->field_cellCentre().ptr();
}
sfield (lhs) ::= WEIGHT_AVERAGE LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volAverage(*lhs);
}
vfield (lhs) ::= WEIGHT_AVERAGE LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volAverage(*lhs);
}
hfield (lhs) ::= WEIGHT_AVERAGE LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volAverage(*lhs);
}
yfield (lhs) ::= WEIGHT_AVERAGE LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volAverage(*lhs);
}
tfield (lhs) ::= WEIGHT_AVERAGE LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volAverage(*lhs);
}
sfield (lhs) ::= WEIGHT_SUM LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volSum(*lhs);
}
vfield (lhs) ::= WEIGHT_SUM LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volSum(*lhs);
}
hfield (lhs) ::= WEIGHT_SUM LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volSum(*lhs);
}
yfield (lhs) ::= WEIGHT_SUM LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volSum(*lhs);
}
tfield (lhs) ::= WEIGHT_SUM LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = driver->volSum(*lhs);
}



/* * * * * * * * * * * * * * * * Surface Fields  * * * * * * * * * * * * * * *\
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/*---------------------------------------------------------------------------*\
 * Productions (surfaceScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= ssfield (a) . { driver->setResult(a); }

ssfield (lhs) ::= FACE_EXPR LPAREN svalue (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>(make_obj(a)).ptr();
}

ssfield (lhs) ::= SSCALAR_ID (name) .
{
    lhs = driver->getSurfaceField<Foam::scalar>(make_obj(name.name_)).ptr();
}


ssfield (lhs) ::= LPAREN ssfield (a) RPAREN. { lhs = a; }
ssfield (lhs) ::= MINUS ssfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

ssfield (lhs) ::= DEG_TO_RAD LPAREN ssfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

ssfield (lhs) ::= RAD_TO_DEG LPAREN ssfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

ssfield (lhs) ::= MIN LPAREN ssfield (a) COMMA ssfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

ssfield (lhs) ::= MAX LPAREN ssfield (a) COMMA ssfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

slfield (lhs) ::= ssfield (a) EQUAL ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::scalar>());
}

slfield (lhs) ::= ssfield (a) NOT_EQUAL ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::scalar>());
}

slfield (lhs) ::= ssfield (a) LESS ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::scalar>());
}

slfield (lhs) ::= ssfield (a) LESS_EQUAL ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::scalar>());
}

slfield (lhs) ::= ssfield (a) GREATER ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::scalar>());
}

slfield (lhs) ::= ssfield (a) GREATER_EQUAL ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::scalar>());
}

ssfield (lhs) ::= slfield (cond) QUESTION ssfield (a) COLON ssfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::scalar,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




ssfield (lhs) ::= MIN LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

ssfield (lhs) ::= MAX LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

ssfield (lhs) ::= SUM LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

ssfield (lhs) ::= AVERAGE LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


ssfield (lhs) ::= ssfield (a) PLUS ssfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ssfield (lhs) ::= ssfield (a) MINUS ssfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ssfield (lhs) ::= ssfield (a) TIMES ssfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ssfield (lhs) ::= ssfield (a) DIVIDE ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::scalar>()
    );
}

ssfield (lhs) ::= ssfield (a) PERCENT ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarModuloOp<Foam::scalar>()
    );
}

ssfield (lhs) ::= svfield (a) BIT_AND svfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ssfield (lhs) ::= EXP LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::exp (make_tmp(a)).ptr();
}

ssfield (lhs) ::= LOG LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::log (make_tmp(a)).ptr();
}

ssfield (lhs) ::= LOG10 LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::log10 (make_tmp(a)).ptr();
}

ssfield (lhs) ::= SQR LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::sqr (make_tmp(a)).ptr();
}

ssfield (lhs) ::= SQRT LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::sqrt (make_tmp(a)).ptr();
}

ssfield (lhs) ::= CBRT LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::cbrt (make_tmp(a)).ptr();
}

ssfield (lhs) ::= SIN LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::sin (make_tmp(a)).ptr();
}

ssfield (lhs) ::= COS LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::cos (make_tmp(a)).ptr();
}

ssfield (lhs) ::= TAN LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::tan (make_tmp(a)).ptr();
}

ssfield (lhs) ::= ASIN LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::asin (make_tmp(a)).ptr();
}

ssfield (lhs) ::= ACOS LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::acos (make_tmp(a)).ptr();
}

ssfield (lhs) ::= ATAN LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::atan (make_tmp(a)).ptr();
}

ssfield (lhs) ::= SINH LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::sinh (make_tmp(a)).ptr();
}

ssfield (lhs) ::= COSH LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::cosh (make_tmp(a)).ptr();
}

ssfield (lhs) ::= TANH LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::tanh (make_tmp(a)).ptr();
}

ssfield (lhs) ::= POW LPAREN ssfield (a) COMMA ssfield (b) RPAREN .
{
    lhs = Foam::pow(make_tmp(a), make_tmp(b)).ptr();
}

ssfield (lhs) ::= ATAN2 LPAREN ssfield (a) COMMA ssfield (b) RPAREN .
{
    lhs = Foam::atan2(make_tmp(a), make_tmp(b)).ptr();
}

ssfield (lhs) ::= POS LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::pos (make_tmp(a)).ptr();
}

ssfield (lhs) ::= NEG LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::neg (make_tmp(a)).ptr();
}

ssfield (lhs) ::= POS0 LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::pos0 (make_tmp(a)).ptr();
}

ssfield (lhs) ::= NEG0 LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::neg0 (make_tmp(a)).ptr();
}

ssfield (lhs) ::= SIGN LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::sign (make_tmp(a)).ptr();
}



// Non-standard but manage via FieldOps::assign
ssfield (lhs) ::= FLOOR LPAREN ssfield (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::floorOp<Foam::scalar>());
}

ssfield (lhs) ::= CEIL LPAREN ssfield (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::ceilOp<Foam::scalar>());
}

ssfield (lhs) ::= ROUND LPAREN ssfield (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::roundOp<Foam::scalar>());
}


// Non-standard but manage via FieldOps::assign
ssfield (lhs) ::= HYPOT LPAREN ssfield (a) COMMA ssfield (b) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::hypotOp<Foam::scalar>());
}


ssfield (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN ssfield (values) RPAREN.
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    driver->fillFunctionValues<Foam::scalar>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (surfaceVectorField)
\*---------------------------------------------------------------------------*/

evaluate ::= svfield (a) . { driver->setResult(a); }

svfield (lhs) ::= FACE_EXPR LPAREN vvalue (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::vector>(make_obj(a)).ptr();
}

svfield (lhs) ::= SVECTOR_ID (name) .
{
    lhs = driver->getSurfaceField<Foam::vector>(make_obj(name.name_)).ptr();
}


svfield (lhs) ::= LPAREN svfield (a) RPAREN. { lhs = a; }
svfield (lhs) ::= MINUS svfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

svfield (lhs) ::= DEG_TO_RAD LPAREN svfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

svfield (lhs) ::= RAD_TO_DEG LPAREN svfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

svfield (lhs) ::= MIN LPAREN svfield (a) COMMA svfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

svfield (lhs) ::= MAX LPAREN svfield (a) COMMA svfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

slfield (lhs) ::= svfield (a) EQUAL svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::vector>());
}

slfield (lhs) ::= svfield (a) NOT_EQUAL svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::vector>());
}

slfield (lhs) ::= svfield (a) LESS svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::vector>());
}

slfield (lhs) ::= svfield (a) LESS_EQUAL svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::vector>());
}

slfield (lhs) ::= svfield (a) GREATER svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::vector>());
}

slfield (lhs) ::= svfield (a) GREATER_EQUAL svfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::vector>());
}

svfield (lhs) ::= slfield (cond) QUESTION svfield (a) COLON svfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::vector,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




svfield (lhs) ::= MIN LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

svfield (lhs) ::= MAX LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

svfield (lhs) ::= SUM LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

svfield (lhs) ::= AVERAGE LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


svfield (lhs) ::= svfield (a) PLUS svfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) MINUS svfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) TIMES ssfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

svfield (lhs) ::= ssfield (a) TIMES svfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) DIVIDE ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::vector>()
    );
}

svfield (lhs) ::= svfield (a) BIT_XOR svfield (b) .
{
    lhs = (make_tmp(a) ^ make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) BIT_AND stfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) BIT_AND syfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

svfield (lhs) ::= svfield (a) BIT_AND shfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

svfield (lhs) ::= stfield (a) BIT_AND svfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

svfield (lhs) ::= syfield (a) BIT_AND svfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

svfield (lhs) ::= shfield (a) BIT_AND svfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




svfield (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN ssfield (values) RPAREN.
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();
    driver->fillFunctionValues<Foam::vector>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (surfaceSphericalTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= shfield (a) . { driver->setResult(a); }

shfield (lhs) ::= SSPH_TENSOR_ID (name) .
{
    lhs = driver->getSurfaceField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}

shfield (lhs) ::= LPAREN shfield (a) RPAREN. { lhs = a; }
shfield (lhs) ::= MINUS shfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

shfield (lhs) ::= DEG_TO_RAD LPAREN shfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

shfield (lhs) ::= RAD_TO_DEG LPAREN shfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

shfield (lhs) ::= MIN LPAREN shfield (a) COMMA shfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

shfield (lhs) ::= MAX LPAREN shfield (a) COMMA shfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

slfield (lhs) ::= shfield (a) EQUAL shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::sphericalTensor>());
}

slfield (lhs) ::= shfield (a) NOT_EQUAL shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::sphericalTensor>());
}

slfield (lhs) ::= shfield (a) LESS shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::sphericalTensor>());
}

slfield (lhs) ::= shfield (a) LESS_EQUAL shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::sphericalTensor>());
}

slfield (lhs) ::= shfield (a) GREATER shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::sphericalTensor>());
}

slfield (lhs) ::= shfield (a) GREATER_EQUAL shfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::sphericalTensor>());
}

shfield (lhs) ::= slfield (cond) QUESTION shfield (a) COLON shfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::sphericalTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




shfield (lhs) ::= MIN LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

shfield (lhs) ::= MAX LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

shfield (lhs) ::= SUM LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

shfield (lhs) ::= AVERAGE LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


shfield (lhs) ::= shfield (a) PLUS shfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

shfield (lhs) ::= shfield (a) MINUS shfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

shfield (lhs) ::= shfield (a) TIMES ssfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

shfield (lhs) ::= ssfield (a) TIMES shfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

shfield (lhs) ::= shfield (a) DIVIDE ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::sphericalTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::sphericalTensor>()
    );
}





/*---------------------------------------------------------------------------*\
 * Productions (surfaceSymmTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= syfield (a) . { driver->setResult(a); }

syfield (lhs) ::= SSYM_TENSOR_ID (name) .
{
    lhs = driver->getSurfaceField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}


syfield (lhs) ::= LPAREN syfield (a) RPAREN. { lhs = a; }
syfield (lhs) ::= MINUS syfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

syfield (lhs) ::= DEG_TO_RAD LPAREN syfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

syfield (lhs) ::= RAD_TO_DEG LPAREN syfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

syfield (lhs) ::= MIN LPAREN syfield (a) COMMA syfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

syfield (lhs) ::= MAX LPAREN syfield (a) COMMA syfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

slfield (lhs) ::= syfield (a) EQUAL syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::symmTensor>());
}

slfield (lhs) ::= syfield (a) NOT_EQUAL syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::symmTensor>());
}

slfield (lhs) ::= syfield (a) LESS syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::symmTensor>());
}

slfield (lhs) ::= syfield (a) LESS_EQUAL syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::symmTensor>());
}

slfield (lhs) ::= syfield (a) GREATER syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::symmTensor>());
}

slfield (lhs) ::= syfield (a) GREATER_EQUAL syfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::symmTensor>());
}

syfield (lhs) ::= slfield (cond) QUESTION syfield (a) COLON syfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::symmTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




syfield (lhs) ::= MIN LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

syfield (lhs) ::= MAX LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

syfield (lhs) ::= SUM LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

syfield (lhs) ::= AVERAGE LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


syfield (lhs) ::= syfield (a) PLUS syfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

syfield (lhs) ::= syfield (a) PLUS shfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

syfield (lhs) ::= shfield (a) PLUS syfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

syfield (lhs) ::= syfield (a) MINUS syfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

syfield (lhs) ::= syfield (a) MINUS shfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

syfield (lhs) ::= shfield (a) MINUS syfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

syfield (lhs) ::= syfield (a) TIMES ssfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

syfield (lhs) ::= ssfield (a) TIMES syfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

syfield (lhs) ::= syfield (a) DIVIDE ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::symmTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::symmTensor>()
    );
}

syfield (lhs) ::= syfield (a) BIT_AND shfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

syfield (lhs) ::= shfield (a) BIT_AND syfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Productions (surfaceTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= stfield (a) . { driver->setResult(a); }

stfield (lhs) ::= STENSOR_ID (name) .
{
    lhs = driver->getSurfaceField<Foam::tensor>(make_obj(name.name_)).ptr();
}


stfield (lhs) ::= LPAREN stfield (a) RPAREN. { lhs = a; }
stfield (lhs) ::= MINUS stfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

stfield (lhs) ::= DEG_TO_RAD LPAREN stfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

stfield (lhs) ::= RAD_TO_DEG LPAREN stfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

stfield (lhs) ::= MIN LPAREN stfield (a) COMMA stfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

stfield (lhs) ::= MAX LPAREN stfield (a) COMMA stfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

slfield (lhs) ::= stfield (a) EQUAL stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::tensor>());
}

slfield (lhs) ::= stfield (a) NOT_EQUAL stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::tensor>());
}

slfield (lhs) ::= stfield (a) LESS stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::tensor>());
}

slfield (lhs) ::= stfield (a) LESS_EQUAL stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::tensor>());
}

slfield (lhs) ::= stfield (a) GREATER stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::tensor>());
}

slfield (lhs) ::= stfield (a) GREATER_EQUAL stfield (b) .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::tensor>());
}

stfield (lhs) ::= slfield (cond) QUESTION stfield (a) COLON stfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::tensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




stfield (lhs) ::= MIN LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

stfield (lhs) ::= MAX LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

stfield (lhs) ::= SUM LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

stfield (lhs) ::= AVERAGE LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


stfield (lhs) ::= stfield (a) PLUS stfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) PLUS syfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

stfield (lhs) ::= syfield (a) PLUS stfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) PLUS shfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

stfield (lhs) ::= shfield (a) PLUS stfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) MINUS stfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) MINUS syfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

stfield (lhs) ::= syfield (a) MINUS stfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) MINUS shfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

stfield (lhs) ::= shfield (a) MINUS stfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) TIMES ssfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

stfield (lhs) ::= ssfield (a) TIMES stfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) DIVIDE ssfield (b) .
{
    lhs = driver->newSurfaceField<Foam::tensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::tensor>()
    );
}

stfield (lhs) ::= svfield (a) TIMES svfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) BIT_AND stfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) BIT_AND shfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

stfield (lhs) ::= stfield (a) BIT_AND syfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

stfield (lhs) ::= shfield (a) BIT_AND stfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

stfield (lhs) ::= syfield (a) BIT_AND stfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

stfield (lhs) ::= syfield (a) BIT_AND syfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Logic field productions (surfaceScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= slfield (a) . { driver->setResult(a, true); /* Logical */ }

slfield (lhs) ::= FACE_EXPR LPAREN LTRUE RPAREN .  { lhs = driver->newSurfaceField<Foam::scalar>(Foam::scalar(1)).ptr(); }
slfield (lhs) ::= FACE_EXPR LPAREN LFALSE RPAREN . { lhs = driver->newSurfaceField<Foam::scalar>(Foam::scalar(0)).ptr(); }

slfield (lhs) ::= BOOL LPAREN slfield (a) RPAREN .
{
    lhs = a;
}

slfield (lhs) ::= BOOL LPAREN ssfield (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();

    Foam::FieldOps::assign
    (
        *lhs, make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}


slfield (lhs) ::= LPAREN slfield (a) RPAREN. { lhs = a; }
slfield (lhs) ::= LNOT slfield (a). [NEGATE]
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a,
        Foam::expressions::boolNotOp<Foam::scalar>()
    );
}

slfield (lhs) ::= slfield (a) LAND slfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolAndOp<Foam::scalar>()
    );
}

slfield (lhs) ::= slfield (a) LOR slfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolOrOp<Foam::scalar>()
    );
}




/*---------------------------------------------------------------------------*\
 * General Surface-related productions
\*---------------------------------------------------------------------------*/

slfield (lhs) ::= FACE_SET LPAREN identifier (name) RPAREN .{    lhs = driver->field_faceSet(make_obj(name)).ptr();}slfield (lhs) ::= FACE_ZONE LPAREN identifier (name) RPAREN .{    lhs = driver->field_faceZone(make_obj(name)).ptr();}ssfield (lhs) ::= FACE_AREA LPAREN RPAREN .
{
    lhs = driver->field_faceArea().ptr();
}
svfield (lhs) ::= FACE_CENTRE LPAREN RPAREN .
{
    lhs = driver->field_faceCentre().ptr();
}
svfield (lhs) ::= FACE_EXPR LPAREN RPAREN .
{
    lhs = driver->field_areaNormal().ptr();
}
ssfield (lhs) ::= WEIGHT_AVERAGE LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
svfield (lhs) ::= WEIGHT_AVERAGE LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
shfield (lhs) ::= WEIGHT_AVERAGE LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
syfield (lhs) ::= WEIGHT_AVERAGE LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
stfield (lhs) ::= WEIGHT_AVERAGE LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
ssfield (lhs) ::= WEIGHT_SUM LPAREN ssfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
svfield (lhs) ::= WEIGHT_SUM LPAREN svfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
shfield (lhs) ::= WEIGHT_SUM LPAREN shfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
syfield (lhs) ::= WEIGHT_SUM LPAREN syfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
stfield (lhs) ::= WEIGHT_SUM LPAREN stfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}


// End disable_surface_fields


/* * * * * * * * * * * * * * * * Point Fields  * * * * * * * * * * * * * * * *\


\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/*---------------------------------------------------------------------------*\
 * Productions (pointScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= psfield (a) . { driver->setResult(a); }

psfield (lhs) ::= POINT_EXPR LPAREN svalue (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>(make_obj(a)).ptr();
}

psfield (lhs) ::= PSCALAR_ID (name) .
{
    lhs = driver->getPointField<Foam::scalar>(make_obj(name.name_)).ptr();
}


psfield (lhs) ::= LPAREN psfield (a) RPAREN. { lhs = a; }
psfield (lhs) ::= MINUS psfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

psfield (lhs) ::= DEG_TO_RAD LPAREN psfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

psfield (lhs) ::= RAD_TO_DEG LPAREN psfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

psfield (lhs) ::= MIN LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

psfield (lhs) ::= MAX LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= psfield (a) EQUAL psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) NOT_EQUAL psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) LESS psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) LESS_EQUAL psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) GREATER psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) GREATER_EQUAL psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::scalar>());
}

psfield (lhs) ::= plfield (cond) QUESTION psfield (a) COLON psfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::scalar,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




psfield (lhs) ::= MIN LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

psfield (lhs) ::= MAX LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

psfield (lhs) ::= SUM LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

psfield (lhs) ::= AVERAGE LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}



// Non-standard but manage via FieldOps::assign
psfield (lhs) ::= FLOOR LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::floorOp<Foam::scalar>());
}

psfield (lhs) ::= CEIL LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::ceilOp<Foam::scalar>());
}

psfield (lhs) ::= ROUND LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::roundOp<Foam::scalar>());
}


// Non-standard but manage via FieldOps::assign
psfield (lhs) ::= HYPOT LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::hypotOp<Foam::scalar>());
}


psfield (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN psfield (values) RPAREN.
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    driver->fillFunctionValues<Foam::scalar>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Some special handling for point fields.
 * Some operators are incomplete, or ambiguous.
 * Just calculate directly on the primitiveField, which is not as bad as it
 * sounds since most of the pointPatchField operators are dummies (no-op)
 * anyhow.
\*---------------------------------------------------------------------------*/

psfield (lhs) ::= psfield (a) PLUS psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        (make_obj(a).primitiveField() + make_obj(b).primitiveField());
}

psfield (lhs) ::= psfield (a) MINUS psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        (make_obj(a).primitiveField() - make_obj(b).primitiveField());
}

psfield (lhs) ::= psfield (a) TIMES psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        (make_obj(a).primitiveField() * make_obj(b).primitiveField());
}

psfield (lhs) ::= psfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::scalar>()
    );
}

psfield (lhs) ::= psfield (a) PERCENT psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarModuloOp<Foam::scalar>()
    );
}

psfield (lhs) ::= pvfield (a) BIT_AND pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        (make_obj(a).primitiveField() & make_obj(b).primitiveField());
}

psfield (lhs) ::= EXP LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::exp (make_obj(a).primitiveField());
}

psfield (lhs) ::= LOG LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::log (make_obj(a).primitiveField());
}

psfield (lhs) ::= LOG10 LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::log10 (make_obj(a).primitiveField());
}

psfield (lhs) ::= SQR LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::sqr (make_obj(a).primitiveField());
}

psfield (lhs) ::= SQRT LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::sqrt (make_obj(a).primitiveField());
}

psfield (lhs) ::= CBRT LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::cbrt (make_obj(a).primitiveField());
}

psfield (lhs) ::= SIN LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::sin (make_obj(a).primitiveField());
}

psfield (lhs) ::= COS LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::cos (make_obj(a).primitiveField());
}

psfield (lhs) ::= TAN LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::tan (make_obj(a).primitiveField());
}

psfield (lhs) ::= ASIN LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::asin (make_obj(a).primitiveField());
}

psfield (lhs) ::= ACOS LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::acos (make_obj(a).primitiveField());
}

psfield (lhs) ::= ATAN LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::atan (make_obj(a).primitiveField());
}

psfield (lhs) ::= SINH LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::sinh (make_obj(a).primitiveField());
}

psfield (lhs) ::= COSH LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::cosh (make_obj(a).primitiveField());
}

psfield (lhs) ::= TANH LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() = Foam::tanh (make_obj(a).primitiveField());
}

psfield (lhs) ::= POW LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        Foam::pow(make_obj(a).primitiveField(), make_obj(b).primitiveField());
}

psfield (lhs) ::= ATAN2 LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    (*lhs).primitiveFieldRef() =
        Foam::atan2(make_obj(a).primitiveField(), make_obj(b).primitiveField());
}










/*---------------------------------------------------------------------------*\
 * Productions (pointVectorField)
\*---------------------------------------------------------------------------*/

evaluate ::= pvfield (a) . { driver->setResult(a); }

pvfield (lhs) ::= POINT_EXPR LPAREN vvalue (a) RPAREN .
{
    lhs = driver->newPointField<Foam::vector>(make_obj(a)).ptr();
}

pvfield (lhs) ::= PVECTOR_ID (name) .
{
    lhs = driver->getPointField<Foam::vector>(make_obj(name.name_)).ptr();
}


pvfield (lhs) ::= LPAREN pvfield (a) RPAREN. { lhs = a; }
pvfield (lhs) ::= MINUS pvfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

pvfield (lhs) ::= DEG_TO_RAD LPAREN pvfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

pvfield (lhs) ::= RAD_TO_DEG LPAREN pvfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

pvfield (lhs) ::= MIN LPAREN pvfield (a) COMMA pvfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

pvfield (lhs) ::= MAX LPAREN pvfield (a) COMMA pvfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= pvfield (a) EQUAL pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) NOT_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) LESS pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) LESS_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) GREATER pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) GREATER_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::vector>());
}

pvfield (lhs) ::= plfield (cond) QUESTION pvfield (a) COLON pvfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::vector,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




pvfield (lhs) ::= MIN LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

pvfield (lhs) ::= MAX LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

pvfield (lhs) ::= SUM LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

pvfield (lhs) ::= AVERAGE LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


pvfield (lhs) ::= pvfield (a) PLUS pvfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) MINUS pvfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pvfield (lhs) ::= psfield (a) TIMES pvfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::vector>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::vector>()
    );
}

pvfield (lhs) ::= pvfield (a) BIT_XOR pvfield (b) .
{
    lhs = (make_tmp(a) ^ make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= ptfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pyfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= phfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




pvfield (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN psfield (values) RPAREN.
{
    lhs = driver->newPointField<Foam::vector>().ptr();
    driver->fillFunctionValues<Foam::vector>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}

/*---------------------------------------------------------------------------*\
 * Productions (pointSphericalTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= phfield (a) . { driver->setResult(a); }

phfield (lhs) ::= PSPH_TENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}


phfield (lhs) ::= LPAREN phfield (a) RPAREN. { lhs = a; }
phfield (lhs) ::= MINUS phfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

phfield (lhs) ::= DEG_TO_RAD LPAREN phfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

phfield (lhs) ::= RAD_TO_DEG LPAREN phfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

phfield (lhs) ::= MIN LPAREN phfield (a) COMMA phfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

phfield (lhs) ::= MAX LPAREN phfield (a) COMMA phfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= phfield (a) EQUAL phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) NOT_EQUAL phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) LESS phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) LESS_EQUAL phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) GREATER phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) GREATER_EQUAL phfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::sphericalTensor>());
}

phfield (lhs) ::= plfield (cond) QUESTION phfield (a) COLON phfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::sphericalTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




phfield (lhs) ::= MIN LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

phfield (lhs) ::= MAX LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

phfield (lhs) ::= SUM LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

phfield (lhs) ::= AVERAGE LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


phfield (lhs) ::= phfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

phfield (lhs) ::= psfield (a) TIMES phfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::sphericalTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::sphericalTensor>()
    );
}





/*---------------------------------------------------------------------------*\
 * Productions (pointSymmTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= pyfield (a) . { driver->setResult(a); }

pyfield (lhs) ::= PSYM_TENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}


pyfield (lhs) ::= LPAREN pyfield (a) RPAREN. { lhs = a; }
pyfield (lhs) ::= MINUS pyfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

pyfield (lhs) ::= DEG_TO_RAD LPAREN pyfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

pyfield (lhs) ::= RAD_TO_DEG LPAREN pyfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

pyfield (lhs) ::= MIN LPAREN pyfield (a) COMMA pyfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

pyfield (lhs) ::= MAX LPAREN pyfield (a) COMMA pyfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= pyfield (a) EQUAL pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) NOT_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) LESS pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) LESS_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) GREATER pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) GREATER_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::symmTensor>());
}

pyfield (lhs) ::= plfield (cond) QUESTION pyfield (a) COLON pyfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::symmTensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




pyfield (lhs) ::= MIN LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

pyfield (lhs) ::= MAX LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

pyfield (lhs) ::= SUM LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

pyfield (lhs) ::= AVERAGE LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


pyfield (lhs) ::= pyfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pyfield (lhs) ::= psfield (a) TIMES pyfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::symmTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::symmTensor>()
    );
}

pyfield (lhs) ::= pyfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Productions (pointTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= ptfield (a) . { driver->setResult(a); }

ptfield (lhs) ::= PTENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::tensor>(make_obj(name.name_)).ptr();
}


ptfield (lhs) ::= LPAREN ptfield (a) RPAREN. { lhs = a; }
ptfield (lhs) ::= MINUS ptfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

ptfield (lhs) ::= DEG_TO_RAD LPAREN ptfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

ptfield (lhs) ::= RAD_TO_DEG LPAREN ptfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

ptfield (lhs) ::= MIN LPAREN ptfield (a) COMMA ptfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

ptfield (lhs) ::= MAX LPAREN ptfield (a) COMMA ptfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= ptfield (a) EQUAL ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) NOT_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) LESS ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) LESS_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) GREATER ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) GREATER_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::tensor>());
}

ptfield (lhs) ::= plfield (cond) QUESTION ptfield (a) COLON ptfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::tensor,Foam::scalar>
    (
        *lhs, make_obj(cond), *a, make_obj(b),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}




ptfield (lhs) ::= MIN LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

ptfield (lhs) ::= MAX LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

ptfield (lhs) ::= SUM LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

ptfield (lhs) ::= AVERAGE LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


ptfield (lhs) ::= ptfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= psfield (a) TIMES ptfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::tensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::tensor>()
    );
}

ptfield (lhs) ::= pvfield (a) TIMES pvfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




/*---------------------------------------------------------------------------*\
 * Logic field productions (pointScalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= plfield (a) . { driver->setResult(a, true); /* Logical */ }

plfield (lhs) ::= POINT_EXPR LPAREN LTRUE RPAREN .  { lhs = driver->newPointField<Foam::scalar>(Foam::scalar(1)).ptr(); }
plfield (lhs) ::= POINT_EXPR LPAREN LFALSE RPAREN . { lhs = driver->newPointField<Foam::scalar>(Foam::scalar(0)).ptr(); }
plfield (lhs) ::= LPAREN plfield (a) RPAREN. { lhs = a; }
plfield (lhs) ::= LNOT plfield (a). [NEGATE]
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a,
        Foam::expressions::boolNotOp<Foam::scalar>()
    );
}

plfield (lhs) ::= plfield (a) LAND plfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolAndOp<Foam::scalar>()
    );
}

plfield (lhs) ::= plfield (a) LOR plfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolOrOp<Foam::scalar>()
    );
}




/*---------------------------------------------------------------------------*\
 * General Point-related productions
\*---------------------------------------------------------------------------*/

plfield (lhs) ::= POINT_SET LPAREN identifier (name) RPAREN .{    lhs = driver->field_pointSet(make_obj(*name)).ptr();}plfield (lhs) ::= POINT_ZONE LPAREN identifier (name) RPAREN .{    lhs = driver->field_pointZone(make_obj(*name)).ptr();}pvfield (lhs) ::= POINTS LPAREN RPAREN .
{
    lhs = driver->field_pointField().ptr();
}
psfield (lhs) ::= WEIGHT_AVERAGE LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
pvfield (lhs) ::= WEIGHT_AVERAGE LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
phfield (lhs) ::= WEIGHT_AVERAGE LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
pyfield (lhs) ::= WEIGHT_AVERAGE LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
ptfield (lhs) ::= WEIGHT_AVERAGE LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
psfield (lhs) ::= WEIGHT_SUM LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
pvfield (lhs) ::= WEIGHT_SUM LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
phfield (lhs) ::= WEIGHT_SUM LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
pyfield (lhs) ::= WEIGHT_SUM LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
ptfield (lhs) ::= WEIGHT_SUM LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}


// End disable_point_fields

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/*---------------------------------------------------------------------------*\
 * Volume field composition
\*---------------------------------------------------------------------------*/

sfield (lhs) ::= MAG LPAREN lfield (a) RPAREN .
{
    lhs = driver->newVolField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}

sfield (lhs) ::= MAG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN sfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN vfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN vfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN tfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN tfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN yfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN yfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN hfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN hfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}



vfield (lhs) ::= VECTOR LPAREN sfield (x) COMMA sfield (y) COMMA sfield (z) RPAREN.
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(x)),
        (make_obj(y)),
        (make_obj(z))
    );
}

tfield (lhs) ::= TENSOR LPAREN
    sfield (xx) COMMA sfield (xy) COMMA sfield (xz) COMMA
    sfield (yx) COMMA sfield (yy) COMMA sfield (yz) COMMA
    sfield (zx) COMMA sfield (zy) COMMA sfield (zz)
RPAREN.
{
    lhs = driver->newVolField<Foam::tensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yx)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zx)),
        (make_obj(zy)),
        (make_obj(zz))
    );
}

yfield (lhs) ::= SYM_TENSOR LPAREN
    sfield (xx) COMMA sfield (xy) COMMA sfield (xz) COMMA
    sfield (yy) COMMA sfield (yz) COMMA
    sfield (zz)
RPAREN.
{
    lhs = driver->newVolField<Foam::symmTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zz))
    );
}

hfield (lhs) ::= SPH_TENSOR LPAREN sfield (ii) RPAREN.
{
    lhs = driver->newVolField<Foam::sphericalTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(ii))
    );
}


sfield (lhs) ::= vfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::X).ptr();
}

sfield (lhs) ::= vfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Y).ptr();
}

sfield (lhs) ::= vfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Z).ptr();
}


sfield (lhs) ::= tfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XZ).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YZ).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZZ).ptr();
}


sfield (lhs) ::= yfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XX).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XY).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XZ).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YY).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YZ).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::ZZ).ptr();
}


sfield (lhs) ::= hfield (a) DOT CMPT_II LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::sphericalTensor::II).ptr();
}



tfield (lhs) ::= tfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a;
    Foam::T(*lhs, *a);
}

yfield (lhs) ::= yfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}

hfield (lhs) ::= hfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}


vfield (lhs) ::= yfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

vfield (lhs) ::= tfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

vfield (lhs) ::= tfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::X,
        (*lhs)
    );
}

vfield (lhs) ::= tfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Y,
        (*lhs)
    );
}

vfield (lhs) ::= tfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = driver->newVolField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Z,
        (*lhs)
    );
}



sfield (lhs) ::= POINT_TO_CELL LPAREN psfield (a) RPAREN .
{
    lhs = driver->pointToCell(make_obj(a)).ptr();
}

vfield (lhs) ::= POINT_TO_CELL LPAREN pvfield (a) RPAREN .
{
    lhs = driver->pointToCell(make_obj(a)).ptr();
}

tfield (lhs) ::= POINT_TO_CELL LPAREN ptfield (a) RPAREN .
{
    lhs = driver->pointToCell(make_obj(a)).ptr();
}

yfield (lhs) ::= POINT_TO_CELL LPAREN pyfield (a) RPAREN .
{
    lhs = driver->pointToCell(make_obj(a)).ptr();
}

hfield (lhs) ::= POINT_TO_CELL LPAREN phfield (a) RPAREN .
{
    lhs = driver->pointToCell(make_obj(a)).ptr();
}


vfield (lhs) ::= RECONSTRUCT LPAREN ssfield (a) RPAREN.
{
    lhs = Foam::fvc::reconstruct(make_obj(a)).ptr();
}


/*---------------------------------------------------------------------------*\
 * Surface field composition
\*---------------------------------------------------------------------------*/

ssfield (lhs) ::= MAG LPAREN slfield (a) RPAREN .
{
    lhs = driver->newSurfaceField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}

ssfield (lhs) ::= MAG LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

ssfield (lhs) ::= MAGSQR LPAREN ssfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


ssfield (lhs) ::= MAG LPAREN svfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

ssfield (lhs) ::= MAGSQR LPAREN svfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


ssfield (lhs) ::= MAG LPAREN stfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

ssfield (lhs) ::= MAGSQR LPAREN stfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


ssfield (lhs) ::= MAG LPAREN syfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

ssfield (lhs) ::= MAGSQR LPAREN syfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


ssfield (lhs) ::= MAG LPAREN shfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

ssfield (lhs) ::= MAGSQR LPAREN shfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}



svfield (lhs) ::= VECTOR LPAREN ssfield (x) COMMA ssfield (y) COMMA ssfield (z) RPAREN.
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(x)),
        (make_obj(y)),
        (make_obj(z))
    );
}

stfield (lhs) ::= TENSOR LPAREN
    ssfield (xx) COMMA ssfield (xy) COMMA ssfield (xz) COMMA
    ssfield (yx) COMMA ssfield (yy) COMMA ssfield (yz) COMMA
    ssfield (zx) COMMA ssfield (zy) COMMA ssfield (zz)
RPAREN.
{
    lhs = driver->newSurfaceField<Foam::tensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yx)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zx)),
        (make_obj(zy)),
        (make_obj(zz))
    );
}

syfield (lhs) ::= SYM_TENSOR LPAREN
    ssfield (xx) COMMA ssfield (xy) COMMA ssfield (xz) COMMA
    ssfield (yy) COMMA ssfield (yz) COMMA
    ssfield (zz)
RPAREN.
{
    lhs = driver->newSurfaceField<Foam::symmTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zz))
    );
}

shfield (lhs) ::= SPH_TENSOR LPAREN ssfield (ii) RPAREN.
{
    lhs = driver->newSurfaceField<Foam::sphericalTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(ii))
    );
}


ssfield (lhs) ::= svfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::X).ptr();
}

ssfield (lhs) ::= svfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Y).ptr();
}

ssfield (lhs) ::= svfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Z).ptr();
}


ssfield (lhs) ::= stfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XX).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XY).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XZ).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_YX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YX).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YY).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YZ).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_ZX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZX).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_ZY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZY).ptr();
}

ssfield (lhs) ::= stfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZZ).ptr();
}


ssfield (lhs) ::= syfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XX).ptr();
}

ssfield (lhs) ::= syfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XY).ptr();
}

ssfield (lhs) ::= syfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XZ).ptr();
}

ssfield (lhs) ::= syfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YY).ptr();
}

ssfield (lhs) ::= syfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YZ).ptr();
}

ssfield (lhs) ::= syfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::ZZ).ptr();
}


ssfield (lhs) ::= shfield (a) DOT CMPT_II LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::sphericalTensor::II).ptr();
}



stfield (lhs) ::= stfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a;
    Foam::T(*lhs, *a);
}

syfield (lhs) ::= syfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}

shfield (lhs) ::= shfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}


svfield (lhs) ::= syfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

svfield (lhs) ::= stfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

svfield (lhs) ::= stfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::X,
        (*lhs)
    );
}

svfield (lhs) ::= stfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Y,
        (*lhs)
    );
}

svfield (lhs) ::= stfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = driver->newSurfaceField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Z,
        (*lhs)
    );
}



ssfield (lhs) ::= CELL_TO_FACE LPAREN sfield (a) RPAREN .
{
    lhs = driver->cellToFace(make_obj(a)).ptr();
}

svfield (lhs) ::= CELL_TO_FACE LPAREN vfield (a) RPAREN .
{
    lhs = driver->cellToFace(make_obj(a)).ptr();
}

stfield (lhs) ::= CELL_TO_FACE LPAREN tfield (a) RPAREN .
{
    lhs = driver->cellToFace(make_obj(a)).ptr();
}

syfield (lhs) ::= CELL_TO_FACE LPAREN yfield (a) RPAREN .
{
    lhs = driver->cellToFace(make_obj(a)).ptr();
}

shfield (lhs) ::= CELL_TO_FACE LPAREN hfield (a) RPAREN .
{
    lhs = driver->cellToFace(make_obj(a)).ptr();
}



/*---------------------------------------------------------------------------*\
 * Point field composition
 * - Use primitiveField directly
\*---------------------------------------------------------------------------*/

psfield (lhs) ::= MAG LPAREN plfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}

psfield (lhs) ::= MAG LPAREN psfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN psfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN pvfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN pvfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN ptfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN ptfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN pyfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN pyfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN phfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN phfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}



pvfield (lhs) ::= VECTOR LPAREN psfield (x) COMMA psfield (y) COMMA psfield (z) RPAREN.
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::zip
    (
        (*lhs).primitiveFieldRef(),
        (make_obj(x)).primitiveField(),
        (make_obj(y)).primitiveField(),
        (make_obj(z)).primitiveField()
    );
}

ptfield (lhs) ::= TENSOR LPAREN
    psfield (xx) COMMA psfield (xy) COMMA psfield (xz) COMMA
    psfield (yx) COMMA psfield (yy) COMMA psfield (yz) COMMA
    psfield (zx) COMMA psfield (zy) COMMA psfield (zz)
RPAREN.
{
    lhs = driver->newPointField<Foam::tensor>().ptr();

    Foam::zip
    (
        (*lhs).primitiveFieldRef(),
        (make_obj(xx)).primitiveField(),
        (make_obj(xy)).primitiveField(),
        (make_obj(xz)).primitiveField(),
        (make_obj(yx)).primitiveField(),
        (make_obj(yy)).primitiveField(),
        (make_obj(yz)).primitiveField(),
        (make_obj(zx)).primitiveField(),
        (make_obj(zy)).primitiveField(),
        (make_obj(zz)).primitiveField()
    );
}

pyfield (lhs) ::= SYM_TENSOR LPAREN
    psfield (xx) COMMA psfield (xy) COMMA psfield (xz) COMMA
    psfield (yy) COMMA psfield (yz) COMMA
    psfield (zz)
RPAREN.
{
    lhs = driver->newPointField<Foam::symmTensor>().ptr();

    Foam::zip
    (
        (*lhs).primitiveFieldRef(),
        (make_obj(xx)).primitiveField(),
        (make_obj(xy)).primitiveField(),
        (make_obj(xz)).primitiveField(),
        (make_obj(yy)).primitiveField(),
        (make_obj(yz)).primitiveField(),
        (make_obj(zz)).primitiveField()
    );
}

phfield (lhs) ::= SPH_TENSOR LPAREN psfield (ii) RPAREN.
{
    lhs = driver->newPointField<Foam::sphericalTensor>().ptr();

    Foam::zip
    (
        (*lhs).primitiveFieldRef(),
        (make_obj(ii)).primitiveField()
    );
}


psfield (lhs) ::= pvfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::X).ptr();
}

psfield (lhs) ::= pvfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Y).ptr();
}

psfield (lhs) ::= pvfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Z).ptr();
}


psfield (lhs) ::= ptfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XZ).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YZ).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZZ).ptr();
}


psfield (lhs) ::= pyfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XX).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XY).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XZ).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YY).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YZ).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::ZZ).ptr();
}


psfield (lhs) ::= phfield (a) DOT CMPT_II LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::sphericalTensor::II).ptr();
}



ptfield (lhs) ::= ptfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a;
    Foam::T(*lhs, *a);
}

pyfield (lhs) ::= pyfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}

phfield (lhs) ::= phfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}


pvfield (lhs) ::= pyfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)).primitiveField(), (*lhs).primitiveFieldRef());
}

pvfield (lhs) ::= ptfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)).primitiveField(), (*lhs).primitiveFieldRef());
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)).primitiveField(),
        Foam::vector::X,
        (*lhs).primitiveFieldRef()
    );
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)).primitiveField(),
        Foam::vector::Y,
        (*lhs).primitiveFieldRef()
    );
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)).primitiveField(),
        Foam::vector::Z,
        (*lhs).primitiveFieldRef()
    );
}



psfield (lhs) ::= CELL_TO_POINT LPAREN sfield (a) RPAREN .
{
    lhs = driver->cellToPoint(make_obj(a)).ptr();
}

pvfield (lhs) ::= CELL_TO_POINT LPAREN vfield (a) RPAREN .
{
    lhs = driver->cellToPoint(make_obj(a)).ptr();
}

ptfield (lhs) ::= CELL_TO_POINT LPAREN tfield (a) RPAREN .
{
    lhs = driver->cellToPoint(make_obj(a)).ptr();
}

pyfield (lhs) ::= CELL_TO_POINT LPAREN yfield (a) RPAREN .
{
    lhs = driver->cellToPoint(make_obj(a)).ptr();
}

phfield (lhs) ::= CELL_TO_POINT LPAREN hfield (a) RPAREN .
{
    lhs = driver->cellToPoint(make_obj(a)).ptr();
}




// ************************************************************************* //

/*
 * include m4/lemon/parser-methods.m4
 */


%code
{

// * * * * * * * * * * * * * Static Member Functions * * * * * * * * * * * * //

Foam::word Foam::expressions::volumeExpr::parser::tokenName(int i)
{
    #ifndef NDEBUG
    if (i > 0 && unsigned(i) < (sizeof(yyTokenName) / sizeof(char*)))
    {
        return *(yyTokenName + i);
    }
    return "<invalid>";
    #else
    return "";
    #endif
}

void Foam::expressions::volumeExpr::parser::printTokenNames(Ostream& os)
{
    #ifndef NDEBUG
    const unsigned nElem(sizeof(yyTokenName) / sizeof(char*));
    for (unsigned i = 1; i < nElem; ++i) // start = 1 (skip termination token)
    {
        os << *(yyTokenName + i) << nl;
    }
    #endif
}

void Foam::expressions::volumeExpr::parser::printRules(Ostream& os)
{
    #ifndef NDEBUG
    const unsigned nElem(sizeof(yyRuleName) / sizeof(char*));

    // Easy way to count number of digits
    const unsigned width(std::to_string(nElem).length());

    for (unsigned i = 0; i < nElem; ++i)
    {
        os << setw(width) << i << ": " << *(yyRuleName + i) << nl;
    }
    #endif
}



// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

void Foam::expressions::volumeExpr::parser::stop()
{
    if (lemon_)
    {
        ParseFree(lemon_, ::operator delete);
        #ifndef NDEBUG
        ParseTrace(nullptr, nullptr);
        #endif
        lemon_ = nullptr;
    }
}


void Foam::expressions::volumeExpr::parser::start(parseDriver& driver_)
{
    this->stop();
    lemon_ = ParseAlloc(::operator new, &driver_);

    if ((debug & 0x4) || driver_.debugParser())
    {
        #ifndef NDEBUG
        ParseTrace(stderr, const_cast<char*>(prompt_));
        #endif
    }
}


void Foam::expressions::volumeExpr::parser::parse(int tokenId)
{
    Parse(lemon_, tokenId, scanToken::null());
}


void Foam::expressions::volumeExpr::parser::parse(int tokenId, scanToken tok)
{
    Parse(lemon_, tokenId, tok);
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

}  // End of %code

// ************************************************************************* //
