%include
{
/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Copyright (C) 2019-2021 OpenCFD Ltd.
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Description
    Lemon grammar for patch expressions.

    https://www.sqlite.org/src/doc/trunk/doc/lemon.html

    See detailed notes in the field expression parser.

\*---------------------------------------------------------------------------*/
} // %include

/*
 * include patchExprLemonParserMacros.m4
 * !done in a comment since many editors have issues matching m4 quotes!
 */
%include
{
#include "exprScanToken.H"
#include "patchExprDriver.H"
#include "patchExprParser.H"
#include "patchExprScanner.H"
#include "unitConversion.H"
#include "volFields.H"
#include "error.H"
#include "IOmanip.H"
#include "exprOps.H"
#include "exprDriverOps.H"
#include "GeometricFieldOps.H"

// Enable ParseTrace
#undef NDEBUG

#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wsign-compare"

// Local Functions

//- Create a tmp from a pointer, taking ownership
template<class T>
Foam::tmp<T> make_tmp(T* p)
{
    return Foam::tmp<T>(p);
}

//- Default make_obj is pass-through
template<class T>
const T& make_obj(const T& o) noexcept
{
    return o;
}

//- Move construct an object from a pointer and destroy the pointer
template<class T>
T make_obj(T*& p)
{
    T o(std::move(*p));
    delete p;
    p = nullptr;  // Prevent caller from deleting too
    return o;
}


} // %include

// ------------------------------------------------------------------------- //

// File-scope visibility for exposed Lemon parser routines
%static

// Use extra argument for the return value
%extra_context  { Foam::expressions::patchExpr::parseDriver* driver }
%parse_failure  { driver->reportFatal("Parse failure, giving up..."); }
%syntax_error   { driver->reportFatal("Syntax error"); }

%token_prefix TOK_

// Terminals
%token_type         {Foam::expressions::scanToken}
%token_destructor   { ($$).destroy(); }

// Face fields
%type lfield { Foam::boolField* }
%type sfield { Foam::scalarField* }
%type vfield { Foam::vectorField* }
%type hfield { Foam::sphericalTensorField* }
%type yfield { Foam::symmTensorField* }
%type tfield { Foam::tensorField* }

// Point fields
%type plfield { Foam::boolField* }
%type psfield { Foam::scalarField* }
%type pvfield { Foam::vectorField* }
%type phfield { Foam::sphericalTensorField* }
%type pyfield { Foam::symmTensorField* }
%type ptfield { Foam::tensorField* }


// For each rule action with code, destruction must be done by that code block
// Lemon does not generate a destructor for that.
// So do not use Lemon destructors for anything.

// Standard tokens for operators, constants and common types
%token
  LPAREN RPAREN COMMA
  QUESTION COLON LOR LAND LNOT
  BIT_OR BIT_XOR BIT_AND BIT_NOT
  EQUAL NOT_EQUAL
  LESS LESS_EQUAL GREATER GREATER_EQUAL
  PLUS MINUS TIMES DIVIDE PERCENT
  NEGATE DOT
  BOOL LTRUE LFALSE
  NUMBER ZERO IDENTIFIER
.

// https://en.cppreference.com/w/cpp/language/operator_precedence
%right QUESTION COLON .                 // 13: right-to-left
%left LOR  .                            // 12:
%left LAND .                            // 11:
%left BIT_OR  .                         // 10 (unused)
%left BIT_XOR .                         // 9
%left BIT_AND .                         // 8
%left EQUAL NOT_EQUAL .                 // 7
%left LESS LESS_EQUAL GREATER GREATER_EQUAL . // 6
%left PLUS MINUS .                      // 4
%left TIMES DIVIDE PERCENT .            // 3
%right NEGATE LNOT BIT_NOT .            // 2: right-to-left
%left DOT  .                            // 1: (method)


%start_symbol evaluate

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/*---------------------------------------------------------------------------*\
 * General Productions
\*---------------------------------------------------------------------------*/

%type identifier { Foam::word* }
%destructor identifier { delete($$); $$ = nullptr; }

identifier (lhs) ::= IDENTIFIER (tok) .
{
    // Take ownership of pointer from scan token
    lhs = tok.name_; tok.name_ = nullptr;
}

/*---------------------------------------------------------------------------*\
 * Productions (scalar)
\*---------------------------------------------------------------------------*/

%type svalue { Foam::scalar }

svalue (lhs) ::= NUMBER (tok) .     { lhs = (tok).scalarValue; } // scanToken
svalue (lhs) ::= ZERO .             { lhs = Foam::Zero; }
svalue (lhs) ::= PI LPAREN RPAREN . { lhs = Foam::constant::mathematical::pi; }
svalue (lhs) ::= DEG_TO_RAD LPAREN RPAREN . { lhs = Foam::degToRad(); }
svalue (lhs) ::= RAD_TO_DEG LPAREN RPAREN . { lhs = Foam::radToDeg(); }
svalue (lhs) ::= ARG LPAREN RPAREN .  { lhs = driver->argValue(); }
svalue (lhs) ::= TIME LPAREN RPAREN . { lhs = driver->timeValue(); }
svalue (lhs) ::= DELTA_T LPAREN RPAREN . { lhs = driver->deltaT(); }

svalue (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN RPAREN .
{
    lhs = driver->getFunctionValue<Foam::scalar>
    (
        make_obj(name.name_),
        driver->timeValue()
    );
}

/*---------------------------------------------------------------------------*\
 * Productions (vector)
\*---------------------------------------------------------------------------*/

%type vvalue { Foam::vector* }
%destructor vvalue { delete($$); $$ = nullptr; }

vvalue (lhs) ::= VECTOR_VALUE (tok) .
{
    // Take ownership of pointer from scan token
    lhs = tok.vectorPtr; tok.vectorPtr = nullptr;
}

vvalue (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN RPAREN .
{
    auto val = driver->getFunctionValue<Foam::vector>
    (
        make_obj(name.name_),
        driver->timeValue()
    );
    lhs = new Foam::vector(val);
}


/* * * * * * * * * * * * * * * * * Face Fields * * * * * * * * * * * * * * * *\
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*---------------------------------------------------------------------------*\
 * Productions (scalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= sfield (a) . { driver->setResult(a); }

sfield (lhs) ::= svalue (a) .
{
    lhs = driver->newField<Foam::scalar>(make_obj(a)).ptr();
}

sfield (lhs) ::= SCALAR_ID (name) .
{
    lhs = driver->getField<Foam::scalar>(make_obj(name.name_)).ptr();
}

sfield (lhs) ::= SSCALAR_ID (name) .
{
    lhs = driver->getField<Foam::scalar>(make_obj(name.name_)).ptr();
}

sfield (lhs) ::= INTERNAL_FIELD LPAREN SCALAR_ID (name) RPAREN .
{
    lhs = driver->patchInternalField<Foam::scalar>(make_obj(name.name_)).ptr();
}
sfield (lhs) ::= NEIGHBOUR_FIELD LPAREN SCALAR_ID (name) RPAREN .
{
    lhs = driver->patchNeighbourField<Foam::scalar>(make_obj(name.name_)).ptr();
}
sfield (lhs) ::= SN_GRAD LPAREN SCALAR_ID (name) RPAREN .
{
    lhs = driver->patchNormalField<Foam::scalar>(make_obj(name.name_)).ptr();
}


sfield (lhs) ::= LPAREN sfield (a) RPAREN. { lhs = a; }
sfield (lhs) ::= MINUS sfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

sfield (lhs) ::= DEG_TO_RAD LPAREN sfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

sfield (lhs) ::= RAD_TO_DEG LPAREN sfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

sfield (lhs) ::= MIN LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= MAX LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= sfield (a) EQUAL sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) NOT_EQUAL sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) LESS sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) LESS_EQUAL sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) GREATER sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::scalar>());
}

lfield (lhs) ::= sfield (a) GREATER_EQUAL sfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::scalar>());
}

sfield (lhs) ::= lfield (cond) QUESTION sfield (a) COLON sfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::scalar>(*lhs, make_obj(cond), *a, make_obj(b));
}




sfield (lhs) ::= MIN LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

sfield (lhs) ::= MAX LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

sfield (lhs) ::= SUM LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

sfield (lhs) ::= AVERAGE LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


sfield (lhs) ::= sfield (a) PLUS sfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) MINUS sfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

sfield (lhs) ::= sfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::scalar>()
    );
}

sfield (lhs) ::= sfield (a) PERCENT sfield (b) .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarModuloOp<Foam::scalar>()
    );
}

sfield (lhs) ::= vfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

sfield (lhs) ::= EXP LPAREN sfield (a) RPAREN .
{
    lhs = Foam::exp (make_tmp(a)).ptr();
}

sfield (lhs) ::= LOG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::log (make_tmp(a)).ptr();
}

sfield (lhs) ::= LOG10 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::log10 (make_tmp(a)).ptr();
}

sfield (lhs) ::= SQR LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sqr (make_tmp(a)).ptr();
}

sfield (lhs) ::= SQRT LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sqrt (make_tmp(a)).ptr();
}

sfield (lhs) ::= CBRT LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cbrt (make_tmp(a)).ptr();
}

sfield (lhs) ::= SIN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sin (make_tmp(a)).ptr();
}

sfield (lhs) ::= COS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cos (make_tmp(a)).ptr();
}

sfield (lhs) ::= TAN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::tan (make_tmp(a)).ptr();
}

sfield (lhs) ::= ASIN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::asin (make_tmp(a)).ptr();
}

sfield (lhs) ::= ACOS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::acos (make_tmp(a)).ptr();
}

sfield (lhs) ::= ATAN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::atan (make_tmp(a)).ptr();
}

sfield (lhs) ::= SINH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sinh (make_tmp(a)).ptr();
}

sfield (lhs) ::= COSH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::cosh (make_tmp(a)).ptr();
}

sfield (lhs) ::= TANH LPAREN sfield (a) RPAREN .
{
    lhs = Foam::tanh (make_tmp(a)).ptr();
}

sfield (lhs) ::= POW LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::pow(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= ATAN2 LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::atan2(make_tmp(a), make_tmp(b)).ptr();
}

sfield (lhs) ::= POS LPAREN sfield (a) RPAREN .
{
    lhs = Foam::pos (make_tmp(a)).ptr();
}

sfield (lhs) ::= NEG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::neg (make_tmp(a)).ptr();
}

sfield (lhs) ::= POS0 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::pos0 (make_tmp(a)).ptr();
}

sfield (lhs) ::= NEG0 LPAREN sfield (a) RPAREN .
{
    lhs = Foam::neg0 (make_tmp(a)).ptr();
}

sfield (lhs) ::= SIGN LPAREN sfield (a) RPAREN .
{
    lhs = Foam::sign (make_tmp(a)).ptr();
}



// Non-standard but manage via FieldOps::assign
sfield (lhs) ::= FLOOR LPAREN sfield (a) RPAREN .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::floorOp<Foam::scalar>());
}

sfield (lhs) ::= CEIL LPAREN sfield (a) RPAREN .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::ceilOp<Foam::scalar>());
}

sfield (lhs) ::= ROUND LPAREN sfield (a) RPAREN .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::roundOp<Foam::scalar>());
}


// Non-standard but works directly for scalarField
sfield (lhs) ::= HYPOT LPAREN sfield (a) COMMA sfield (b) RPAREN .
{
    lhs = Foam::hypot(make_tmp(a), make_tmp(b)).ptr();
}



// Other functions

sfield (lhs) ::= RAND LPAREN RPAREN.
{
    lhs = driver->field_rand().ptr();
}

sfield (lhs) ::= RAND LPAREN NUMBER (seed) RPAREN.
{
    // Call with -ve seed to signal use of time index as seed
    lhs = driver->field_rand(std::round(-(seed).scalarValue)).ptr();
}

sfield (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN sfield (values) RPAREN.
{
    lhs = driver->newField<Foam::scalar>().ptr();
    driver->fillFunctionValues<Foam::scalar>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (vectorField)
\*---------------------------------------------------------------------------*/

evaluate ::= vfield (a) . { driver->setResult(a); }

vfield (lhs) ::= vvalue (a) .
{
    lhs = driver->newField<Foam::vector>(make_obj(a)).ptr();
}

vfield (lhs) ::= VECTOR_ID (name) .
{
    lhs = driver->getField<Foam::vector>(make_obj(name.name_)).ptr();
}

vfield (lhs) ::= SVECTOR_ID (name) .
{
    lhs = driver->getField<Foam::vector>(make_obj(name.name_)).ptr();
}

vfield (lhs) ::= INTERNAL_FIELD LPAREN VECTOR_ID (name) RPAREN .
{
    lhs = driver->patchInternalField<Foam::vector>(make_obj(name.name_)).ptr();
}
vfield (lhs) ::= NEIGHBOUR_FIELD LPAREN VECTOR_ID (name) RPAREN .
{
    lhs = driver->patchNeighbourField<Foam::vector>(make_obj(name.name_)).ptr();
}
vfield (lhs) ::= SN_GRAD LPAREN VECTOR_ID (name) RPAREN .
{
    lhs = driver->patchNormalField<Foam::vector>(make_obj(name.name_)).ptr();
}


vfield (lhs) ::= LPAREN vfield (a) RPAREN. { lhs = a; }
vfield (lhs) ::= MINUS vfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

vfield (lhs) ::= DEG_TO_RAD LPAREN vfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

vfield (lhs) ::= RAD_TO_DEG LPAREN vfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

vfield (lhs) ::= MIN LPAREN vfield (a) COMMA vfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

vfield (lhs) ::= MAX LPAREN vfield (a) COMMA vfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= vfield (a) EQUAL vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) NOT_EQUAL vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) LESS vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) LESS_EQUAL vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) GREATER vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::vector>());
}

lfield (lhs) ::= vfield (a) GREATER_EQUAL vfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::vector>());
}

vfield (lhs) ::= lfield (cond) QUESTION vfield (a) COLON vfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::vector>(*lhs, make_obj(cond), *a, make_obj(b));
}




vfield (lhs) ::= MIN LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

vfield (lhs) ::= MAX LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

vfield (lhs) ::= SUM LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

vfield (lhs) ::= AVERAGE LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


vfield (lhs) ::= vfield (a) PLUS vfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) MINUS vfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

vfield (lhs) ::= sfield (a) TIMES vfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newField<Foam::vector>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::vector>()
    );
}

vfield (lhs) ::= vfield (a) BIT_XOR vfield (b) .
{
    lhs = (make_tmp(a) ^ make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= vfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= tfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= yfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

vfield (lhs) ::= hfield (a) BIT_AND vfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




// Other functions

vfield (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN sfield (values) RPAREN.
{
    lhs = driver->newField<Foam::vector>().ptr();
    driver->fillFunctionValues<Foam::vector>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (sphericalTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= hfield (a) . { driver->setResult(a); }

hfield (lhs) ::= SPH_TENSOR_ID (name) .
{
    lhs = driver->getField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}

hfield (lhs) ::= SSPH_TENSOR_ID (name) .
{
    lhs = driver->getField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}

hfield (lhs) ::= INTERNAL_FIELD LPAREN SPH_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchInternalField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}
hfield (lhs) ::= NEIGHBOUR_FIELD LPAREN SPH_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNeighbourField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}
hfield (lhs) ::= SN_GRAD LPAREN SPH_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNormalField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}


hfield (lhs) ::= LPAREN hfield (a) RPAREN. { lhs = a; }
hfield (lhs) ::= MINUS hfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

hfield (lhs) ::= DEG_TO_RAD LPAREN hfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

hfield (lhs) ::= RAD_TO_DEG LPAREN hfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

hfield (lhs) ::= MIN LPAREN hfield (a) COMMA hfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

hfield (lhs) ::= MAX LPAREN hfield (a) COMMA hfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= hfield (a) EQUAL hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) NOT_EQUAL hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) LESS hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) LESS_EQUAL hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) GREATER hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::sphericalTensor>());
}

lfield (lhs) ::= hfield (a) GREATER_EQUAL hfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::sphericalTensor>());
}

hfield (lhs) ::= lfield (cond) QUESTION hfield (a) COLON hfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::sphericalTensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




hfield (lhs) ::= MIN LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

hfield (lhs) ::= MAX LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

hfield (lhs) ::= SUM LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

hfield (lhs) ::= AVERAGE LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


hfield (lhs) ::= hfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

hfield (lhs) ::= sfield (a) TIMES hfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

hfield (lhs) ::= hfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newField<Foam::sphericalTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::sphericalTensor>()
    );
}





/*---------------------------------------------------------------------------*\
 * Productions (symmTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= yfield (a) . { driver->setResult(a); }

yfield (lhs) ::= SYM_TENSOR_ID (name) .
{
    lhs = driver->getField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}

yfield (lhs) ::= SSYM_TENSOR_ID (name) .
{
    lhs = driver->getField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}

yfield (lhs) ::= INTERNAL_FIELD LPAREN SYM_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchInternalField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}
yfield (lhs) ::= NEIGHBOUR_FIELD LPAREN SYM_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNeighbourField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}
yfield (lhs) ::= SN_GRAD LPAREN SYM_TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNormalField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}


yfield (lhs) ::= LPAREN yfield (a) RPAREN. { lhs = a; }
yfield (lhs) ::= MINUS yfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

yfield (lhs) ::= DEG_TO_RAD LPAREN yfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

yfield (lhs) ::= RAD_TO_DEG LPAREN yfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

yfield (lhs) ::= MIN LPAREN yfield (a) COMMA yfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

yfield (lhs) ::= MAX LPAREN yfield (a) COMMA yfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= yfield (a) EQUAL yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) NOT_EQUAL yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) LESS yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) LESS_EQUAL yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) GREATER yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::symmTensor>());
}

lfield (lhs) ::= yfield (a) GREATER_EQUAL yfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::symmTensor>());
}

yfield (lhs) ::= lfield (cond) QUESTION yfield (a) COLON yfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::symmTensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




yfield (lhs) ::= MIN LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

yfield (lhs) ::= MAX LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

yfield (lhs) ::= SUM LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

yfield (lhs) ::= AVERAGE LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


yfield (lhs) ::= yfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

yfield (lhs) ::= sfield (a) TIMES yfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

yfield (lhs) ::= yfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newField<Foam::symmTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::symmTensor>()
    );
}

yfield (lhs) ::= yfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

yfield (lhs) ::= hfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Productions (tensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= tfield (a) . { driver->setResult(a); }
tfield (lhs) ::= IDENTITY_TENSOR . { lhs = driver->newField<Foam::tensor>(Foam::tensor::I).ptr(); }

tfield (lhs) ::= TENSOR_ID (name) .
{
    lhs = driver->getField<Foam::tensor>(make_obj(name.name_)).ptr();
}

tfield (lhs) ::= STENSOR_ID (name) .
{
    lhs = driver->getField<Foam::tensor>(make_obj(name.name_)).ptr();
}

tfield (lhs) ::= INTERNAL_FIELD LPAREN TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchInternalField<Foam::tensor>(make_obj(name.name_)).ptr();
}
tfield (lhs) ::= NEIGHBOUR_FIELD LPAREN TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNeighbourField<Foam::tensor>(make_obj(name.name_)).ptr();
}
tfield (lhs) ::= SN_GRAD LPAREN TENSOR_ID (name) RPAREN .
{
    lhs = driver->patchNormalField<Foam::tensor>(make_obj(name.name_)).ptr();
}


tfield (lhs) ::= LPAREN tfield (a) RPAREN. { lhs = a; }
tfield (lhs) ::= MINUS tfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

tfield (lhs) ::= DEG_TO_RAD LPAREN tfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

tfield (lhs) ::= RAD_TO_DEG LPAREN tfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

tfield (lhs) ::= MIN LPAREN tfield (a) COMMA tfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

tfield (lhs) ::= MAX LPAREN tfield (a) COMMA tfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

lfield (lhs) ::= tfield (a) EQUAL tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) NOT_EQUAL tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) LESS tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) LESS_EQUAL tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) GREATER tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::tensor>());
}

lfield (lhs) ::= tfield (a) GREATER_EQUAL tfield (b) .
{
    lhs = driver->newField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::tensor>());
}

tfield (lhs) ::= lfield (cond) QUESTION tfield (a) COLON tfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::tensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




tfield (lhs) ::= MIN LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

tfield (lhs) ::= MAX LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

tfield (lhs) ::= SUM LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

tfield (lhs) ::= AVERAGE LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


tfield (lhs) ::= tfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) PLUS yfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) PLUS hfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) PLUS tfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS yfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) MINUS hfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) MINUS tfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) TIMES sfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= sfield (a) TIMES tfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) DIVIDE sfield (b) .
{
    lhs = driver->newField<Foam::tensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::tensor>()
    );
}

tfield (lhs) ::= vfield (a) TIMES vfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND hfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= tfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= hfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) BIT_AND tfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

tfield (lhs) ::= yfield (a) BIT_AND yfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/*---------------------------------------------------------------------------*\
 * Logic field productions (boolField)
\*---------------------------------------------------------------------------*/

evaluate ::= lfield (a) . { driver->setResult(a); }
lfield (lhs) ::= LTRUE .   { lhs = driver->newField<bool>(true).ptr(); }
lfield (lhs) ::= LFALSE .  { lhs = driver->newField<bool>(false).ptr(); }

lfield (lhs) ::= BOOL LPAREN lfield (a) RPAREN .
{
    lhs = a;
}

lfield (lhs) ::= BOOL LPAREN sfield (a) RPAREN .
{
    lhs = driver->newField<bool>().ptr();

    Foam::FieldOps::assign
    (
        *lhs, make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}


lfield (lhs) ::= SBOOL_ID (name) .
{
    lhs = driver->getSurfaceField<bool>(make_obj(name.name_)).ptr();
}

lfield (lhs) ::= LPAREN lfield (a) RPAREN. { lhs = a; }
lfield (lhs) ::= LNOT lfield (a). [NEGATE]
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a,
        Foam::expressions::boolNotOp<bool>()
    );
}

lfield (lhs) ::= lfield (a) LAND lfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolAndOp<bool>()
    );
}

lfield (lhs) ::= lfield (a) LOR lfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolOrOp<bool>()
    );
}




/*---------------------------------------------------------------------------*\
 * General Surface-related productions
\*---------------------------------------------------------------------------*/

lfield (lhs) ::= CELL_SET LPAREN identifier (name) RPAREN .{    lhs = driver->field_cellSet(make_obj(name)).ptr();
}lfield (lhs) ::= CELL_ZONE LPAREN identifier (name) RPAREN .{    lhs = driver->field_cellZone(make_obj(name)).ptr();
}lfield (lhs) ::= FACE_SET LPAREN identifier (name) RPAREN .{    lhs = driver->field_faceSet(make_obj(name)).ptr();
}lfield (lhs) ::= FACE_ZONE LPAREN identifier (name) RPAREN .{    lhs = driver->field_faceZone(make_obj(name)).ptr();
}sfield (lhs) ::= FACE_AREA LPAREN RPAREN .
{
    lhs = driver->field_faceArea().ptr();
}
vfield (lhs) ::= POS LPAREN RPAREN .
{
    lhs = driver->field_faceCentre().ptr();
}
vfield (lhs) ::= FACE_EXPR LPAREN RPAREN .
{
    lhs = driver->field_areaNormal().ptr();
}
sfield (lhs) ::= WEIGHT_AVERAGE LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
vfield (lhs) ::= WEIGHT_AVERAGE LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
hfield (lhs) ::= WEIGHT_AVERAGE LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
yfield (lhs) ::= WEIGHT_AVERAGE LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
tfield (lhs) ::= WEIGHT_AVERAGE LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaAverage(*lhs);
}
sfield (lhs) ::= WEIGHT_SUM LPAREN sfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
vfield (lhs) ::= WEIGHT_SUM LPAREN vfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
hfield (lhs) ::= WEIGHT_SUM LPAREN hfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
yfield (lhs) ::= WEIGHT_SUM LPAREN yfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}
tfield (lhs) ::= WEIGHT_SUM LPAREN tfield (a) RPAREN .
{
    lhs = a; *lhs = driver->areaSum(*lhs);
}



/* * * * * * * * * * * * * * * * Point Fields  * * * * * * * * * * * * * * * *\
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/*---------------------------------------------------------------------------*\
 * Productions (point scalarField)
\*---------------------------------------------------------------------------*/

evaluate ::= psfield (a) . { driver->setResult(a, true); /* Point */ }

psfield (lhs) ::= POINT_EXPR LPAREN svalue (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>(make_obj(a)).ptr();
}

psfield (lhs) ::= PSCALAR_ID (name) .
{
    lhs = driver->getPointField<Foam::scalar>(make_obj(name.name_)).ptr();
}


psfield (lhs) ::= LPAREN psfield (a) RPAREN. { lhs = a; }
psfield (lhs) ::= MINUS psfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

psfield (lhs) ::= DEG_TO_RAD LPAREN psfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

psfield (lhs) ::= RAD_TO_DEG LPAREN psfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

psfield (lhs) ::= MIN LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

psfield (lhs) ::= MAX LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= psfield (a) EQUAL psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) NOT_EQUAL psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) LESS psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) LESS_EQUAL psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) GREATER psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::scalar>());
}

plfield (lhs) ::= psfield (a) GREATER_EQUAL psfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::scalar>());
}

psfield (lhs) ::= plfield (cond) QUESTION psfield (a) COLON psfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::scalar>(*lhs, make_obj(cond), *a, make_obj(b));
}




psfield (lhs) ::= MIN LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

psfield (lhs) ::= MAX LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

psfield (lhs) ::= SUM LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

psfield (lhs) ::= AVERAGE LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


psfield (lhs) ::= psfield (a) PLUS psfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

psfield (lhs) ::= psfield (a) MINUS psfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

psfield (lhs) ::= psfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

psfield (lhs) ::= psfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::scalar>()
    );
}

psfield (lhs) ::= psfield (a) PERCENT psfield (b) .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarModuloOp<Foam::scalar>()
    );
}

psfield (lhs) ::= pvfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

psfield (lhs) ::= EXP LPAREN psfield (a) RPAREN .
{
    lhs = Foam::exp (make_tmp(a)).ptr();
}

psfield (lhs) ::= LOG LPAREN psfield (a) RPAREN .
{
    lhs = Foam::log (make_tmp(a)).ptr();
}

psfield (lhs) ::= LOG10 LPAREN psfield (a) RPAREN .
{
    lhs = Foam::log10 (make_tmp(a)).ptr();
}

psfield (lhs) ::= SQR LPAREN psfield (a) RPAREN .
{
    lhs = Foam::sqr (make_tmp(a)).ptr();
}

psfield (lhs) ::= SQRT LPAREN psfield (a) RPAREN .
{
    lhs = Foam::sqrt (make_tmp(a)).ptr();
}

psfield (lhs) ::= CBRT LPAREN psfield (a) RPAREN .
{
    lhs = Foam::cbrt (make_tmp(a)).ptr();
}

psfield (lhs) ::= SIN LPAREN psfield (a) RPAREN .
{
    lhs = Foam::sin (make_tmp(a)).ptr();
}

psfield (lhs) ::= COS LPAREN psfield (a) RPAREN .
{
    lhs = Foam::cos (make_tmp(a)).ptr();
}

psfield (lhs) ::= TAN LPAREN psfield (a) RPAREN .
{
    lhs = Foam::tan (make_tmp(a)).ptr();
}

psfield (lhs) ::= ASIN LPAREN psfield (a) RPAREN .
{
    lhs = Foam::asin (make_tmp(a)).ptr();
}

psfield (lhs) ::= ACOS LPAREN psfield (a) RPAREN .
{
    lhs = Foam::acos (make_tmp(a)).ptr();
}

psfield (lhs) ::= ATAN LPAREN psfield (a) RPAREN .
{
    lhs = Foam::atan (make_tmp(a)).ptr();
}

psfield (lhs) ::= SINH LPAREN psfield (a) RPAREN .
{
    lhs = Foam::sinh (make_tmp(a)).ptr();
}

psfield (lhs) ::= COSH LPAREN psfield (a) RPAREN .
{
    lhs = Foam::cosh (make_tmp(a)).ptr();
}

psfield (lhs) ::= TANH LPAREN psfield (a) RPAREN .
{
    lhs = Foam::tanh (make_tmp(a)).ptr();
}

psfield (lhs) ::= POW LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::pow(make_tmp(a), make_tmp(b)).ptr();
}

psfield (lhs) ::= ATAN2 LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::atan2(make_tmp(a), make_tmp(b)).ptr();
}

psfield (lhs) ::= POS LPAREN psfield (a) RPAREN .
{
    lhs = Foam::pos (make_tmp(a)).ptr();
}

psfield (lhs) ::= NEG LPAREN psfield (a) RPAREN .
{
    lhs = Foam::neg (make_tmp(a)).ptr();
}

psfield (lhs) ::= POS0 LPAREN psfield (a) RPAREN .
{
    lhs = Foam::pos0 (make_tmp(a)).ptr();
}

psfield (lhs) ::= NEG0 LPAREN psfield (a) RPAREN .
{
    lhs = Foam::neg0 (make_tmp(a)).ptr();
}

psfield (lhs) ::= SIGN LPAREN psfield (a) RPAREN .
{
    lhs = Foam::sign (make_tmp(a)).ptr();
}



// Non-standard but manage via FieldOps::assign
psfield (lhs) ::= FLOOR LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::floorOp<Foam::scalar>());
}

psfield (lhs) ::= CEIL LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::ceilOp<Foam::scalar>());
}

psfield (lhs) ::= ROUND LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), Foam::roundOp<Foam::scalar>());
}


// Non-standard but works directly for scalarField
psfield (lhs) ::= HYPOT LPAREN psfield (a) COMMA psfield (b) RPAREN .
{
    lhs = Foam::hypot(make_tmp(a), make_tmp(b)).ptr();
}


psfield (lhs) ::= SCALAR_FUNCTION_ID (name) LPAREN psfield (values) RPAREN.
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    driver->fillFunctionValues<Foam::scalar>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (point vectorField)
\*---------------------------------------------------------------------------*/

evaluate ::= pvfield (a) . { driver->setResult(a, true); /* Point */ }

pvfield (lhs) ::= POINT_EXPR LPAREN vvalue (a) RPAREN .
{
    lhs = driver->newPointField<Foam::vector>(make_obj(a)).ptr();
}

pvfield (lhs) ::= PVECTOR_ID (name) .
{
    lhs = driver->getPointField<Foam::vector>(make_obj(name.name_)).ptr();
}


pvfield (lhs) ::= LPAREN pvfield (a) RPAREN. { lhs = a; }
pvfield (lhs) ::= MINUS pvfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

pvfield (lhs) ::= DEG_TO_RAD LPAREN pvfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

pvfield (lhs) ::= RAD_TO_DEG LPAREN pvfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

pvfield (lhs) ::= MIN LPAREN pvfield (a) COMMA pvfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

pvfield (lhs) ::= MAX LPAREN pvfield (a) COMMA pvfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= pvfield (a) EQUAL pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) NOT_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) LESS pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) LESS_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) GREATER pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::vector>());
}

plfield (lhs) ::= pvfield (a) GREATER_EQUAL pvfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::vector>());
}

pvfield (lhs) ::= plfield (cond) QUESTION pvfield (a) COLON pvfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::vector>(*lhs, make_obj(cond), *a, make_obj(b));
}




pvfield (lhs) ::= MIN LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

pvfield (lhs) ::= MAX LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

pvfield (lhs) ::= SUM LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

pvfield (lhs) ::= AVERAGE LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


pvfield (lhs) ::= pvfield (a) PLUS pvfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) MINUS pvfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pvfield (lhs) ::= psfield (a) TIMES pvfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::vector>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::vector>()
    );
}

pvfield (lhs) ::= pvfield (a) BIT_XOR pvfield (b) .
{
    lhs = (make_tmp(a) ^ make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pvfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= ptfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= pyfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pvfield (lhs) ::= phfield (a) BIT_AND pvfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}




pvfield (lhs) ::= VECTOR_FUNCTION_ID (name) LPAREN psfield (values) RPAREN.
{
    lhs = driver->newPointField<Foam::vector>().ptr();
    driver->fillFunctionValues<Foam::vector>
    (
        *lhs,
        make_obj(name.name_),
        make_obj(values)
    );
}


/*---------------------------------------------------------------------------*\
 * Productions (point sphericalTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= phfield (a) . { driver->setResult(a, true); /* Point */ }

phfield (lhs) ::= PSPH_TENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::sphericalTensor>(make_obj(name.name_)).ptr();
}


phfield (lhs) ::= LPAREN phfield (a) RPAREN. { lhs = a; }
phfield (lhs) ::= MINUS phfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

phfield (lhs) ::= DEG_TO_RAD LPAREN phfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

phfield (lhs) ::= RAD_TO_DEG LPAREN phfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

phfield (lhs) ::= MIN LPAREN phfield (a) COMMA phfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

phfield (lhs) ::= MAX LPAREN phfield (a) COMMA phfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= phfield (a) EQUAL phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) NOT_EQUAL phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) LESS phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) LESS_EQUAL phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) GREATER phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::sphericalTensor>());
}

plfield (lhs) ::= phfield (a) GREATER_EQUAL phfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::sphericalTensor>());
}

phfield (lhs) ::= plfield (cond) QUESTION phfield (a) COLON phfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::sphericalTensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




phfield (lhs) ::= MIN LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

phfield (lhs) ::= MAX LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

phfield (lhs) ::= SUM LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

phfield (lhs) ::= AVERAGE LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


phfield (lhs) ::= phfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

phfield (lhs) ::= psfield (a) TIMES phfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

phfield (lhs) ::= phfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::sphericalTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::sphericalTensor>()
    );
}





/*---------------------------------------------------------------------------*\
 * Productions (point symmTensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= pyfield (a) . { driver->setResult(a, true); /* Point */ }

pyfield (lhs) ::= PSYM_TENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::symmTensor>(make_obj(name.name_)).ptr();
}


pyfield (lhs) ::= LPAREN pyfield (a) RPAREN. { lhs = a; }
pyfield (lhs) ::= MINUS pyfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

pyfield (lhs) ::= DEG_TO_RAD LPAREN pyfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

pyfield (lhs) ::= RAD_TO_DEG LPAREN pyfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

pyfield (lhs) ::= MIN LPAREN pyfield (a) COMMA pyfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

pyfield (lhs) ::= MAX LPAREN pyfield (a) COMMA pyfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= pyfield (a) EQUAL pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) NOT_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) LESS pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) LESS_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) GREATER pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::symmTensor>());
}

plfield (lhs) ::= pyfield (a) GREATER_EQUAL pyfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::symmTensor>());
}

pyfield (lhs) ::= plfield (cond) QUESTION pyfield (a) COLON pyfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::symmTensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




pyfield (lhs) ::= MIN LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

pyfield (lhs) ::= MAX LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

pyfield (lhs) ::= SUM LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

pyfield (lhs) ::= AVERAGE LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


pyfield (lhs) ::= pyfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pyfield (lhs) ::= psfield (a) TIMES pyfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

pyfield (lhs) ::= pyfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::symmTensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::symmTensor>()
    );
}

pyfield (lhs) ::= pyfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

pyfield (lhs) ::= phfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Productions (point tensorField)
\*---------------------------------------------------------------------------*/

evaluate ::= ptfield (a) . { driver->setResult(a, true); /* Point */ }

ptfield (lhs) ::= PTENSOR_ID (name) .
{
    lhs = driver->getPointField<Foam::tensor>(make_obj(name.name_)).ptr();
}


ptfield (lhs) ::= LPAREN ptfield (a) RPAREN. { lhs = a; }
ptfield (lhs) ::= MINUS ptfield (a) . [NEGATE]
{
    lhs = a; lhs->negate();
}

ptfield (lhs) ::= DEG_TO_RAD LPAREN ptfield (a) RPAREN .
{
    lhs = ((Foam::degToRad()) * make_tmp(a)).ptr();
}

ptfield (lhs) ::= RAD_TO_DEG LPAREN ptfield (a) RPAREN .
{
    lhs = ((Foam::radToDeg()) * make_tmp(a)).ptr();
}

ptfield (lhs) ::= MIN LPAREN ptfield (a) COMMA ptfield (b) RPAREN .
{
    lhs = Foam::min(make_tmp(a), make_tmp(b)).ptr();
}

ptfield (lhs) ::= MAX LPAREN ptfield (a) COMMA ptfield (b) RPAREN .
{
    lhs = Foam::max(make_tmp(a), make_tmp(b)).ptr();
}

plfield (lhs) ::= ptfield (a) EQUAL ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::equalOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) NOT_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::notEqualOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) LESS ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) LESS_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::lessEqualOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) GREATER ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterOp<Foam::tensor>());
}

plfield (lhs) ::= ptfield (a) GREATER_EQUAL ptfield (b) .
{
    lhs = driver->newPointField<bool>().ptr();
    Foam::FieldOps::assign(*lhs, make_obj(a), make_obj(b), Foam::greaterEqualOp<Foam::tensor>());
}

ptfield (lhs) ::= plfield (cond) QUESTION ptfield (a) COLON ptfield (b) .
{
    lhs = a;

    Foam::FieldOps::ternarySelect
    <Foam::tensor>(*lhs, make_obj(cond), *a, make_obj(b));
}




ptfield (lhs) ::= MIN LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMin (*lhs);
}

ptfield (lhs) ::= MAX LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gMax (*lhs);
}

ptfield (lhs) ::= SUM LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}

ptfield (lhs) ::= AVERAGE LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}


ptfield (lhs) ::= ptfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) PLUS pyfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) PLUS phfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) PLUS ptfield (b) .
{
    lhs = (make_tmp(a) + make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS pyfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) MINUS phfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) MINUS ptfield (b) .
{
    lhs = (make_tmp(a) - make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) TIMES psfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= psfield (a) TIMES ptfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) DIVIDE psfield (b) .
{
    lhs = driver->newPointField<Foam::tensor>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        make_obj(b),
        Foam::scalarDivideOp<Foam::tensor>()
    );
}

ptfield (lhs) ::= pvfield (a) TIMES pvfield (b) .
{
    lhs = (make_tmp(a) * make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND phfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= ptfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= phfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) BIT_AND ptfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}

ptfield (lhs) ::= pyfield (a) BIT_AND pyfield (b) .
{
    lhs = (make_tmp(a) & make_tmp(b)).ptr();
}





/*---------------------------------------------------------------------------*\
 * Logic field productions (point boolField)
\*---------------------------------------------------------------------------*/

evaluate ::= plfield (a) . { driver->setResult(a, true); /* Point */ }
plfield (lhs) ::= POINT_EXPR LPAREN LTRUE RPAREN .  { lhs = driver->newPointField<bool>(true).ptr(); }
plfield (lhs) ::= POINT_EXPR LPAREN LFALSE RPAREN . { lhs = driver->newPointField<bool>(false).ptr(); }

plfield (lhs) ::= BOOL LPAREN plfield (a) RPAREN .
{
    lhs = a;
}

plfield (lhs) ::= BOOL LPAREN psfield (a) RPAREN .
{
    lhs = driver->newPointField<bool>().ptr();

    Foam::FieldOps::assign
    (
        *lhs, make_obj(a),
        Foam::expressions::boolOp<Foam::scalar>()
    );
}


plfield (lhs) ::= PBOOL_ID (name) .
{
    lhs = driver->getPointField<bool>(make_obj(name.name_)).ptr();
}

plfield (lhs) ::= LPAREN plfield (a) RPAREN. { lhs = a; }
plfield (lhs) ::= LNOT plfield (a). [NEGATE]
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a,
        Foam::expressions::boolNotOp<bool>()
    );
}

plfield (lhs) ::= plfield (a) LAND plfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolAndOp<bool>()
    );
}

plfield (lhs) ::= plfield (a) LOR plfield (b) .
{
    lhs = a;
    Foam::FieldOps::assign
    (
        *lhs, *a, make_obj(b),
        Foam::expressions::boolOrOp<bool>()
    );
}




/*---------------------------------------------------------------------------*\
 * General Point-related productions
\*---------------------------------------------------------------------------*/

pvfield (lhs) ::= POINTS LPAREN RPAREN .
{
    lhs = driver->field_pointField().ptr();
}
psfield (lhs) ::= WEIGHT_AVERAGE LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
pvfield (lhs) ::= WEIGHT_AVERAGE LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
phfield (lhs) ::= WEIGHT_AVERAGE LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
pyfield (lhs) ::= WEIGHT_AVERAGE LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
ptfield (lhs) ::= WEIGHT_AVERAGE LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gAverage (*lhs);
}
psfield (lhs) ::= WEIGHT_SUM LPAREN psfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
pvfield (lhs) ::= WEIGHT_SUM LPAREN pvfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
phfield (lhs) ::= WEIGHT_SUM LPAREN phfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
pyfield (lhs) ::= WEIGHT_SUM LPAREN pyfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}
ptfield (lhs) ::= WEIGHT_SUM LPAREN ptfield (a) RPAREN .
{
    lhs = a; *lhs = Foam::gSum (*lhs);
}



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/*---------------------------------------------------------------------------*\
 * Face field composition
\*---------------------------------------------------------------------------*/

sfield (lhs) ::= MAG LPAREN lfield (a) RPAREN .
{
    lhs = driver->newField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        Foam::expressions::boolOp<bool>()
    );
}

sfield (lhs) ::= MAG LPAREN sfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN sfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN vfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN vfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN tfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN tfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN yfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN yfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


sfield (lhs) ::= MAG LPAREN hfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

sfield (lhs) ::= MAGSQR LPAREN hfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}



vfield (lhs) ::= VECTOR LPAREN sfield (x) COMMA sfield (y) COMMA sfield (z) RPAREN.
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(x)),
        (make_obj(y)),
        (make_obj(z))
    );
}

tfield (lhs) ::= TENSOR LPAREN
    sfield (xx) COMMA sfield (xy) COMMA sfield (xz) COMMA
    sfield (yx) COMMA sfield (yy) COMMA sfield (yz) COMMA
    sfield (zx) COMMA sfield (zy) COMMA sfield (zz)
RPAREN.
{
    lhs = driver->newField<Foam::tensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yx)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zx)),
        (make_obj(zy)),
        (make_obj(zz))
    );
}

yfield (lhs) ::= SYM_TENSOR LPAREN
    sfield (xx) COMMA sfield (xy) COMMA sfield (xz) COMMA
    sfield (yy) COMMA sfield (yz) COMMA
    sfield (zz)
RPAREN.
{
    lhs = driver->newField<Foam::symmTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zz))
    );
}

hfield (lhs) ::= SPH_TENSOR LPAREN sfield (ii) RPAREN.
{
    lhs = driver->newField<Foam::sphericalTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(ii))
    );
}


sfield (lhs) ::= vfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::X).ptr();
}

sfield (lhs) ::= vfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Y).ptr();
}

sfield (lhs) ::= vfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Z).ptr();
}


sfield (lhs) ::= tfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XZ).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YZ).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZX).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZY).ptr();
}

sfield (lhs) ::= tfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZZ).ptr();
}


sfield (lhs) ::= yfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XX).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XY).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XZ).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YY).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YZ).ptr();
}

sfield (lhs) ::= yfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::ZZ).ptr();
}


sfield (lhs) ::= hfield (a) DOT CMPT_II LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::sphericalTensor::II).ptr();
}



tfield (lhs) ::= tfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a;
    Foam::T(*lhs, *a);
}

yfield (lhs) ::= yfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}

hfield (lhs) ::= hfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}


vfield (lhs) ::= yfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

vfield (lhs) ::= tfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

vfield (lhs) ::= tfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::X,
        (*lhs)
    );
}

vfield (lhs) ::= tfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Y,
        (*lhs)
    );
}

vfield (lhs) ::= tfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = driver->newField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Z,
        (*lhs)
    );
}



sfield (lhs) ::= POINT_TO_FACE LPAREN psfield (a) RPAREN .
{
    lhs = driver->pointToFace(make_obj(a)).ptr();
}

vfield (lhs) ::= POINT_TO_FACE LPAREN pvfield (a) RPAREN .
{
    lhs = driver->pointToFace(make_obj(a)).ptr();
}

tfield (lhs) ::= POINT_TO_FACE LPAREN ptfield (a) RPAREN .
{
    lhs = driver->pointToFace(make_obj(a)).ptr();
}

yfield (lhs) ::= POINT_TO_FACE LPAREN pyfield (a) RPAREN .
{
    lhs = driver->pointToFace(make_obj(a)).ptr();
}

hfield (lhs) ::= POINT_TO_FACE LPAREN phfield (a) RPAREN .
{
    lhs = driver->pointToFace(make_obj(a)).ptr();
}



/*---------------------------------------------------------------------------*\
 * Point field composition
\*---------------------------------------------------------------------------*/

psfield (lhs) ::= MAG LPAREN plfield (a) RPAREN .
{
    lhs = driver->newPointField<Foam::scalar>().ptr();
    Foam::FieldOps::assign
    (
        *lhs,
        make_obj(a),
        Foam::expressions::boolOp<bool>()
    );
}

psfield (lhs) ::= MAG LPAREN psfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN psfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN pvfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN pvfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN ptfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN ptfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN pyfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN pyfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}


psfield (lhs) ::= MAG LPAREN phfield (a) RPAREN .
{
    lhs = Foam::mag (make_tmp(a)).ptr();
}

psfield (lhs) ::= MAGSQR LPAREN phfield (a) RPAREN .
{
    lhs = Foam::magSqr (make_tmp(a)).ptr();
}



pvfield (lhs) ::= VECTOR LPAREN psfield (x) COMMA psfield (y) COMMA psfield (z) RPAREN.
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(x)),
        (make_obj(y)),
        (make_obj(z))
    );
}

ptfield (lhs) ::= TENSOR LPAREN
    psfield (xx) COMMA psfield (xy) COMMA psfield (xz) COMMA
    psfield (yx) COMMA psfield (yy) COMMA psfield (yz) COMMA
    psfield (zx) COMMA psfield (zy) COMMA psfield (zz)
RPAREN.
{
    lhs = driver->newPointField<Foam::tensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yx)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zx)),
        (make_obj(zy)),
        (make_obj(zz))
    );
}

pyfield (lhs) ::= SYM_TENSOR LPAREN
    psfield (xx) COMMA psfield (xy) COMMA psfield (xz) COMMA
    psfield (yy) COMMA psfield (yz) COMMA
    psfield (zz)
RPAREN.
{
    lhs = driver->newPointField<Foam::symmTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(xx)),
        (make_obj(xy)),
        (make_obj(xz)),
        (make_obj(yy)),
        (make_obj(yz)),
        (make_obj(zz))
    );
}

phfield (lhs) ::= SPH_TENSOR LPAREN psfield (ii) RPAREN.
{
    lhs = driver->newPointField<Foam::sphericalTensor>().ptr();

    Foam::zip
    (
        (*lhs),
        (make_obj(ii))
    );
}


psfield (lhs) ::= pvfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::X).ptr();
}

psfield (lhs) ::= pvfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Y).ptr();
}

psfield (lhs) ::= pvfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::vector::Z).ptr();
}


psfield (lhs) ::= ptfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::XZ).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::YZ).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZX).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZY).ptr();
}

psfield (lhs) ::= ptfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::tensor::ZZ).ptr();
}


psfield (lhs) ::= pyfield (a) DOT CMPT_XX LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XX).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_XY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XY).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_XZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::XZ).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_YY LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YY).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_YZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::YZ).ptr();
}

psfield (lhs) ::= pyfield (a) DOT CMPT_ZZ LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::symmTensor::ZZ).ptr();
}


psfield (lhs) ::= phfield (a) DOT CMPT_II LPAREN RPAREN. [DOT]
{
    lhs = make_tmp(a)->component(Foam::sphericalTensor::II).ptr();
}



ptfield (lhs) ::= ptfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a;
    Foam::T(*lhs, *a);
}

pyfield (lhs) ::= pyfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}

phfield (lhs) ::= phfield (a) DOT TRANSPOSE LPAREN RPAREN. [DOT]
{
    lhs = a; // no-op
}


pvfield (lhs) ::= pyfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

pvfield (lhs) ::= ptfield (a) DOT DIAG LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipDiag((make_obj(a)), (*lhs));
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_X LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::X,
        (*lhs)
    );
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_Y LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Y,
        (*lhs)
    );
}

pvfield (lhs) ::= ptfield (a) DOT CMPT_Z LPAREN RPAREN. [DOT]
{
    lhs = driver->newPointField<Foam::vector>().ptr();

    Foam::unzipRow
    (
        (make_obj(a)),
        Foam::vector::Z,
        (*lhs)
    );
}



psfield (lhs) ::= FACE_TO_POINT LPAREN sfield (a) RPAREN .
{
    lhs = driver->faceToPoint(make_obj(a)).ptr();
}

pvfield (lhs) ::= FACE_TO_POINT LPAREN vfield (a) RPAREN .
{
    lhs = driver->faceToPoint(make_obj(a)).ptr();
}

ptfield (lhs) ::= FACE_TO_POINT LPAREN tfield (a) RPAREN .
{
    lhs = driver->faceToPoint(make_obj(a)).ptr();
}

pyfield (lhs) ::= FACE_TO_POINT LPAREN yfield (a) RPAREN .
{
    lhs = driver->faceToPoint(make_obj(a)).ptr();
}

phfield (lhs) ::= FACE_TO_POINT LPAREN hfield (a) RPAREN .
{
    lhs = driver->faceToPoint(make_obj(a)).ptr();
}



// ************************************************************************* //

/*
 * include m4/lemon/parser-methods.m4
 */

%code
{

// * * * * * * * * * * * * * Static Member Functions * * * * * * * * * * * * //

Foam::word Foam::expressions::patchExpr::parser::tokenName(int i)
{
    #ifndef NDEBUG
    if (i > 0 && unsigned(i) < (sizeof(yyTokenName) / sizeof(char*)))
    {
        return *(yyTokenName + i);
    }
    return "<invalid>";
    #else
    return "";
    #endif
}

void Foam::expressions::patchExpr::parser::printTokenNames(Ostream& os)
{
    #ifndef NDEBUG
    const unsigned nElem(sizeof(yyTokenName) / sizeof(char*));
    for (unsigned i = 1; i < nElem; ++i) // start = 1 (skip termination token)
    {
        os << *(yyTokenName + i) << nl;
    }
    #endif
}

void Foam::expressions::patchExpr::parser::printRules(Ostream& os)
{
    #ifndef NDEBUG
    const unsigned nElem(sizeof(yyRuleName) / sizeof(char*));

    // Easy way to count number of digits
    const unsigned width(std::to_string(nElem).length());

    for (unsigned i = 0; i < nElem; ++i)
    {
        os << setw(width) << i << ": " << *(yyRuleName + i) << nl;
    }
    #endif
}



// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

void Foam::expressions::patchExpr::parser::stop()
{
    if (lemon_)
    {
        ParseFree(lemon_, ::operator delete);
        #ifndef NDEBUG
        ParseTrace(nullptr, nullptr);
        #endif
        lemon_ = nullptr;
    }
}


void Foam::expressions::patchExpr::parser::start(parseDriver& driver_)
{
    this->stop();
    lemon_ = ParseAlloc(::operator new, &driver_);

    if ((debug & 0x4) || driver_.debugParser())
    {
        #ifndef NDEBUG
        ParseTrace(stderr, const_cast<char*>(prompt_));
        #endif
    }
}


void Foam::expressions::patchExpr::parser::parse(int tokenId)
{
    Parse(lemon_, tokenId, scanToken::null());
}


void Foam::expressions::patchExpr::parser::parse(int tokenId, scanToken tok)
{
    Parse(lemon_, tokenId, tok);
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

}  // End of %code

// ************************************************************************* //
